/*
 Navicat Premium Data Transfer

 Source Server         : Telei
 Source Server Type    : MySQL
 Source Server Version : 80013
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 80013
 File Encoding         : 65001

 Date: 20/11/2020 22:37:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_blog
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog`;
CREATE TABLE `tb_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_bin NULL,
  `created` datetime(0) NOT NULL,
  `status` tinyint(255) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 21 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog
-- ----------------------------
INSERT INTO `tb_blog` VALUES (1, 1, 'HTML-9.13作业', '中山职业技术学院就业信息网', '\n\n# HTML-9.13作业\n## 中山职业技术学院就业信息网\n[网站链接](http://cxycyq.gitee.io/html-job/HTML-9.13/index.html)\n\n![效果图](http://cxycyq.gitee.io/my-blgo/images/effect/p1.png)\n\n', '2020-09-30 20:50:22', 0);
INSERT INTO `tb_blog` VALUES (2, 1, 'HTML-9.14作业', '国境外合作网站', '# HTML-9.14作业\n## 国境外合作网站\n**[网站链接](http://cxycyq.gitee.io/html-job/HTML-9.14/index.html)**\n\n![效果图片](http://cxycyq.gitee.io/my-blgo/images/effect/p2.png)', '2020-09-30 22:06:05', 0);
INSERT INTO `tb_blog` VALUES (3, 1, 'HTML-9.21作业', '国内旅游计划', '# HTML-9.21作业\n## 国内旅游计划\n\n[网站链接](http://cxycyq.gitee.io/html-job/HTML-9.21/index.html)\n\n![效果图片](http://cxycyq.gitee.io/my-blgo/images/effect/p3.png)', '2020-10-01 16:37:14', 0);
INSERT INTO `tb_blog` VALUES (4, 1, 'HTML-9.28作业', '个人博客网站', '# HTML-9.28作业\n## 个人博客网站\n\n[网站链接](http://cxycyq.gitee.io/html-job/HTML-9.28/index.html)\n\n![效果图片](http://cxycyq.gitee.io/my-blgo/images/effect/p4.png)\n\n', '2020-10-01 16:38:44', 0);
INSERT INTO `tb_blog` VALUES (5, 1, 'Mybatis学习文档', '个人在学习Mybatis中整理的笔记', '# **MyBatis**介绍：\n\n**Mybatis是一个持久层框架，用java编写的**\n\n**他封装了jdbc操作的很多细节，是开发者只需要关注sql语句本身，无需关注注册驱动，创建连接等操作，它使用了ORM思想实现了很多结果集的封装**\n\n## ORM：\n\n​			**Object Relational Mapping 对象关系映射**\n\n​           **简单说：就是把数据库表和实体类及实体类的属性对应起来**\n\n​           **让我们可以操作实体类就实现操作数据库表**\n\n# **Mybatis** **环境搭建**\n\n### 1、    创建meaven工程并导入坐标\n\n### 2、    创建实体类和dao的接口\n\n### 3、    创建mybatis的主配置文件（SqlMapConfig.xml）\n\n### 4、    创建映射配置文件 （IUserDao.xml）\n\n---\n\n## **环境搭建注意事项**\n\n**1、    创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识一致。在mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper 所以IUserDao 和 IuserMapper是不一样的**\n\n**2、    在idea中创建目录的时候，它和包是不一样的 包在创建的时：com.cyq.dao 它是三级结构 目录在创建时：com.cyq.dao 是一级目录**\n\n**3、    Mybatis的映射配置文件位置必须和dao接口的包结构相同**\n\n**4、    映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名**\n\n**5、    映射配置文件的操作配置(select),id属性的取值必须是dao接口的方法名**\n\n---\n\n# **入门案例**\n\n## 1、    读取/创建配置文件                               \n\n填写路径的两个方法：\n\n~~~java\n//读取配置文件,生成字节流\n         in= Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n~~~\n\n一、   使用类加载器，它只能读取类路径的配置文件\n\n二、   使用ServletContext对象的getRealPath()\n\n## 2、创建SqlSessionFactory工厂\n\n~~~java\n//获取SqlSessionfactory\n        SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);\n~~~\n\n\\#创建工厂mybatis使用了构建者模式，把对象创建细节隐藏，使使用者直接调用方法即可拿到对象\n\n## 3、 创建SqlSession\n\n~~~java\n//获取SqlSession对象\n         sqlSession=factory.openSession();\n~~~\n\n\\#生产SqlSession使用了工厂模式，解耦(降低类之间的依赖关系)\n\n## 4、创建Dao接口的代理对象\n\n```java\n//获取dao对象\n		iuserDaoMapper=sqlSession.getMapper(IuserDaoMapper.class);\n```\n\n #创建Dao接口实现类使用了代理，不修改源码的基础上对已有方法增强\n\n## 5、执行dao中的方法，并遍历输出\n\n~~~java\n//执行查询方法\n        List<User> users= iuserDaoMapper.findAll();\n        for (User user : users){\n            System.out.println(user);\n        }\n~~~\n\n## 6、释放资源\n\n~~~java\n//关闭资源\n        sqlSession.close();\n        in.close();\n~~~\n\n### 注意事项：\n\n**不要忘记在映射配置中告知mybatis要封装到那个实体类中**\n\n​    **配置方式：指定实体类的全限定类名**	\n\n---\n\n# **创建SqlMapConfig.xml** \n\n### Configuration的约束：\n\n~~~xml\n{ <!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n}\n~~~\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    <settings>\n        <!-- 打印查询语句 -->\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\" />\n    </settings>/\n    <!--配置环境 -->\n    <environments default=\"mysql\">\n        <!--配置mysql的环境-->\n        <environment id=\"mysql\">\n            <!--配置事务 -->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置连接池 -->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/wed01?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"799774821\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--配置映射文件的位置 -->\n    <mappers>\n        <mapper resource=\"\\com\\cyq\\dao1\\IUserDao.xml\"></mapper>\n    </mappers>\n</configuration>\n~~~\n\n### URL出错分析\n\n#url：  **;** 用 **&amp** 代替否则报错\n\n**{Caused by: org.xml.sax.SAXParseException; lineNumber: 17; columnNumber: 112; 对实体 \"characterEncoding\" 的引用必须以 \';\' 分隔符结尾。}**\n\n~~~xml\nurl--jdbc:mysql://localhost:3306/wed01?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\n~~~\n\n**#username****固定不能改变 只能使用username，否则报错**\n\n**{Cause: org.apache.ibatis.datasource.DataSourceException: Unknown DataSource property: user}**\n\n# **创建接口**IuserDaoMapper.java\n\n```java\npublic interface IuserDaoMapper{}\n```\n\n### 创建接口方法：\n\n~~~java\n/**\n     * 查询所有用户\n     * @return\n     */\n     List<User> findAll();\n\n    /**\n     * 保存用户\n     * @param user\n     */\n     void saveUser(User user);\n\n    /**\n     * 更新用户\n     * @param user\n     */\n     void updateUser(User user);\n\n    /**\n     * 删除用户\n     * @param userId\n     */\n    void deleteUser(Integer userId);\n\n    /**\n     * 根据ID查询用户信息\n     * @param userId\n     * @return\n     */\n    User findById(Integer userId);\n\n    /**\n     * 根据名称模糊查询用户\n     * @param username\n     * @return\n     */\n    List<User> findByName(String username);\n\n    /**\n     * 查询所有信息数量\n     * @return\n     */\n    int findTotal();\n~~~\n\n---\n\n# **创建User实体类**\n\n### 设置成员变量与连接的数据库字段相同 并赋予get(),set(),toString()方法\n\n~~~java\npublic class User {\n    private String username;\n    private Integer id;\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username=\'\" + username + \'\\\'\' +\n                \", id=\" + id +\n                \", password=\'\" + password + \'\\\'\' +\n                \'}\';\n    }\n}\n~~~\n\n# **创建IuserDao.xml**\n\n### Mapper的约束：\n\n~~~xml\n{<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n~~~\n\n### 在IuserDao.xml中实现接口方法：\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.cyq.dao.IuserDaoMapper\">\n    <!--查询所有 -->\n    <select id=\"findAll\" resultType=\"com.cyq.User\">\n        select * from user;\n    </select>\n\n    <!--新增用户 -->\n    <insert id=\"saveUser\" parameterType=\"com.cyq.User\">\n        insert into user(id,username,password) value(#{id},#{username},#{password})\n    </insert>\n\n    <!--更新用户 -->\n    <update id=\"updateUser\" parameterType=\"com.cyq.User\">\n        update user set id=#{id},username=#{username},password=#{password} where id=#{id};\n    </update>\n\n    <!--删除用户 -->\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id=#{uid};\n    </delete>\n\n    <!--根据id查询用户信息 -->\n    <select id=\"findById\" parameterType=\"java.lang.Integer\" resultType=\"com.cyq.User\">\n        select * from user where id=#{id};\n    </select>\n\n    <!--根据username模糊查询用户信息 -->\n    <select id=\"findByName\" parameterType=\"string\" resultType=\"com.cyq.User\">\n        select * from user where username like #{name};\n    </select>\n\n    <!--查询所有用户信息数量 -->\n    <select id=\"findTotal\" resultType=\"int\">\n        select count(id) from user;\n    </select>\n</mapper>\n~~~\n\n---\n\n# 编写测试类，实现方法：\n\n~~~java\nimport com.cyq.User;\nimport com.cyq.dao.IuserDaoMapper;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.InputStream;\nimport java.util.List;\n\n\n/**\n * 测试mybatis的CRUD操作\n */\npublic class MybatisTest {\n\n        private InputStream in;\n        private SqlSession sqlSession;\n        private IuserDaoMapper iuserDaoMapper;\n\n    @Before//用于测试方法执行之前执行\n    public void init()throws Exception{\n        //读取配置文件,生成字节流\n         in= Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //获取SqlSessionfactory\n        SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);\n        //获取SqlSession对象\n         sqlSession=factory.openSession();\n        //获取dao对象\n        iuserDaoMapper=sqlSession.getMapper(IuserDaoMapper.class);\n    }\n\n    @After//用于测试方法执行之后执行\n    public void close()throws Exception{\n        //提交事务\n        sqlSession.commit();\n\n        //关闭资源\n        sqlSession.close();\n        in.close();\n\n\n    }\n\n    /**\n     * 测试查询所有\n     */\n    @Test\n    public void testFindAll() {\n\n        //执行查询方法\n        List<User> users= iuserDaoMapper.findAll();\n        for (User user : users){\n            System.out.println(user);\n        }\n\n    }\n\n    /**\n     *\n     * 测试保存操作\n     */\n    @Test\n    public void testSave()throws Exception{\n        User user=new User();\n        user.setId(345);\n        user.setUsername(\"cxy\");\n        user.setPassword(\"235\");\n\n        //执行新增用户方法\n        iuserDaoMapper.saveUser(user);\n\n    }\n\n    /**\n     *\n     * 测试更新操作\n     */\n    @Test\n    public void testUpdateUser()throws Exception{\n        User user=new User();\n        user.setId(123);\n        user.setUsername(\"dsfh\");\n        user.setPassword(\"z12xc\");\n\n        //执行新增用户方法\n        iuserDaoMapper.updateUser(user);\n    }\n\n    /**\n     *\n     * 测试更新操作\n     */\n    @Test\n    public void testDelete()throws Exception{\n\n        //执行新增用户方法\n        iuserDaoMapper.deleteUser(234);\n    }\n\n    /**\n     *\n     * 根据id查询用户信息\n     */\n    @Test\n    public void testFindById()throws Exception{\n\n        //执行查询用户方法\n        User user = iuserDaoMapper.findById(1);\n        System.out.println(user);\n    }\n\n    /**\n     *\n     * 根据username模糊查询用户信息\n     */\n    @Test\n    public void testFindByName()throws Exception{\n\n        //执行查询用户方法\n        List<User> users = iuserDaoMapper.findByName(\"%g%\");\n        for (User user:users )\n        System.out.println(user);\n    }\n\n    /**\n     *\n     * 查询所有用户信息数量\n     */\n    @Test\n    public void testFindTotal()throws Exception{\n\n        int count =iuserDaoMapper.findTotal();\n        System.out.println(count);\n    }\n}\n~~~\n\n\n\n# 简化MyBatis创建\n\n## 1、定义变量到方法外\n\n~~~java\nprivate InputStream in;\nprivate SqlSession sqlSession1;\nprivate IuserDaoMapper iuserDaoMapper;\n~~~\n\n## 2、将读取，获取方法放入方法体里（在连接前加@Before注释用于测试方法前执行）\n\n~~~java\n@Before//用于测试方法执行之前执行\npublic void init()throws Exception{\n    //读取配置文件,生成字节流\n     in= Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n    //获取SqlSessionfactory\n    SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);\n    //获取SqlSession对象\n     sqlSession1=factory.openSession();\n    //获取dao对象\n    iuserDaoMapper=sqlSession1.getMapper(IuserDaoMapper.class);\n}\n~~~\n\n## 3、将释放资源操作写入方法体(@After注释用于测试方法执行后)\n\n~~~java\n@After//用于测试方法执行之后执行\npublic void close()throws Exception{\n    //关闭资源\n    sqlSession1.close();\n    in.close();\n}\n~~~\n\n# 设置pom.xml(导入相关依赖)\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.cyq</groupId>\n    <artifactId>Mybatis_study_CRUD</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.4</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.19</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n   <!--静态资源导出问题-->\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n        </resources>\n    </build>\n</project>\n\n~~~\n\n# **使用mybatis实现CRUD的操作**\n\n## 代码实现：\n\n### 新增用户：\n\n~~~java\n/** IuserMapperDao.java\n * 保存用户\n * @param user\n */\n void saveUser(User user);\n------------------------------------------------------------------------------\n<!--新增用户 --> IuserDao.xml\n<insert id=\"saveUser\" parameterType=\"com.cyq.User\">\n    insert into user(id,username,password) value(#{id},#{username},#{password})\n</insert>\n-------------------------------------------------------------------------------\n/**\n *	Test.java\n * 测试保存操作\n */\n@Test\npublic void testSave()throws Exception{\n    User user=new User();\n    user.setId(345);\n    user.setUsername(\"cxy\");\n    user.setPassword(\"235\");\n\n    //执行新增用户方法\n    iuserDaoMapper.saveUser(user);\n}\n~~~\n\n### 更新用户\n\n~~~java\n/** IuserMapperDao.java\n * 更新用户\n * @param user\n */\n void updateUser(User user);\n----------------------------------------------------------------------------\n<!--更新用户 --> IuserDao.xml\n<update id=\"updateUser\" parameterType=\"com.cyq.User\">\n    update user set id=#{id},username=#{username},password=#{password} where id=#{id};\n</update>\n-------------------------------------------------------------------------------\n\n/**\n *	Test.java\n * 测试更新操作\n */\n@Test\npublic void testUpdateUser()throws Exception{\n    User user=new User();\n    user.setId(123);\n    user.setUsername(\"dsfh\");\n    user.setPassword(\"z12xc\");\n\n    //执行新增用户方法\n    iuserDaoMapper.updateUser(user);\n}\n~~~\n\n### 删除用户\n\n~~~java\n/** IuserMapperDao.java\n * 删除用户\n * @param userId\n */\nvoid deleteUser(Integer userId);\n------------------------------------------------------------------------------\n<!--删除用户 --> IuserDao.xml\n<delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n    delete from user where id=#{uid};\n</delete>\n-------------------------------------------------------------------------------\n/**\n *	Test.java\n * 测试删除操作\n */\n@Test\npublic void testDelete()throws Exception{\n\n    //执行新增用户方法\n    iuserDaoMapper.deleteUser(234);\n}\n~~~\n\n### 根据ID查询用户信息\n\n~~~java\n/** IuserMapperDao.java\n * 根据ID查询用户信息\n * @param userId\n * @return\n */\nUser findById(Integer userId);\n------------------------------------------------------------------------------\n<!--根据id查询用户信息 --> IuserDao.xml\n<select id=\"findById\" parameterType=\"java.lang.Integer\" resultType=\"com.cyq.User\">\n    select * from user where id=#{id};\n</select>\n-------------------------------------------------------------------------------\n/**\n *\n * 根据id查询用户信息\n */\n@Test\npublic void testFindById()throws Exception{\n\n    //执行查询用户方法\n    User user = iuserDaoMapper.findById(1);\n    System.out.println(user);\n}\n~~~\n\n### 根据名称模糊查询用户\n\n~~~java\n/**  IuserMapperDao.java\n * 根据名称模糊查询用户\n * @param username\n * @return\n */\nList<User> findByName(String username);\n\n-------------------------------------------------------------------------------\n<!--根据username模糊查询用户信息 -->IuserDao.xml\n<select id=\"findByName\" parameterType=\"string\" resultType=\"com.cyq.User\">\n    select * from user where username like #{name};\n</select>\n-------------------------------------------------------------------------------\n/**\n *\n * 根据username模糊查询用户信息\n */\n@Test\npublic void testFindByName()throws Exception{\n\n    //执行查询用户方法\n    List<User> users = iuserDaoMapper.findByName(\"%g%\");\n    for (User user:users )\n    System.out.println(user);\n}\n~~~\n\n---\n\n# **代理DAO实现CRUD操作**：\n\n## 创建一个DAO类并继承IuserDaoMapper类并重载IuserDaoMapper里面得所有方法:\n\n### 代码实现：\n\n  ~~~java\nimport com.cyq.User;\nimport com.cyq.dao.IuserDaoMapper;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\n\nimport java.util.List;\n\npublic class UserDaoImpl implements IuserDaoMapper {\n\n    private SqlSessionFactory factory;\n\n    public UserDaoImpl(SqlSessionFactory factory){\n        this.factory=factory;\n    }\n\n    @Override\n    public List<User> findAll() {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用SqlSession中的方法，实现查询列表\n        List<User> users = session.selectList(\"com.cyq.dao.IuserDaoMapper.findAll\");//参数就是能获取配置信息的key\n        //3、释放资源\n        session.close();\n        return users;\n    }\n\n    @Override\n    public void saveUser(User user) {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用方法保存\n        session.insert(\"com.cyq.dao.IuserDaoMapper.saveUser\",user);\n        //3、提交事务\n        session.commit();\n        //4、释放资源\n        session.close();\n    }\n\n    @Override\n    public void updateUser(User user) {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用方法更新\n        session.update(\"com.cyq.dao.IuserDaoMapper.updateUser\",user);\n        //3、提交事务\n        session.commit();\n        //4、释放资源\n        session.close();\n    }\n\n    @Override\n    public void deleteUser(Integer userId) {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用方法更新\n        session.delete(\"com.cyq.dao.IuserDaoMapper.deleteUser\",userId);\n        //3、提交事务\n        session.commit();\n        //4、释放资源\n        session.close();\n    }\n\n    @Override\n    public User findById(Integer userId) {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用SqlSession中的方法，实现查询列表\n        User user = session.selectOne(\"com.cyq.dao.IuserDaoMapper.findById\",userId);\n        //3、释放资源\n        session.close();\n        return user;\n    }\n\n    @Override\n    public List<User> findByName(String username) {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用SqlSession中的方法，实现查询列表\n        List<User> user = session.selectList(\"com.cyq.dao.IuserDaoMapper.findByName\",username);\n        //3、释放资源\n        session.close();\n        return user;\n    }\n\n    @Override\n    public int findTotal() {\n        //1、根据factory获取SqlSession对象\n        SqlSession session= factory.openSession();\n        //2、调用SqlSession中的方法，实现查询列表\n       Integer count = session.selectOne(\"com.cyq.dao.IuserDaoMapper.findTotal\");\n        //3、释放资源\n        session.close();\n        return count;\n    }\n}\n  ~~~\n\n---\n\n# **MyBatis注解开发**\n\n## 举例;\n\n**（@ + 方法(Select,Insert,Delete,Update) + sql语句）**\n\n**# 参数前最好加是@param注解  eg: (@param(“str”) String str)**\n\n## **在UserDao中创建方法**\n\n~~~java\n/**\n * 查询所有用户\n * @return\n */\n@Select(\"select * from user\")\nList<User> findAll();\n\n/**\n * 保存用户操作\n * @param user\n */\n@Insert(\"insert into user(id,username,password) values(#{id},#{username},#{password})\")\nvoid saveUser(User user);\n\n/**\n * 删除用户\n * @param i\n */\n@Delete(\"DELETE FROM user WHERE id=#{id}\")\nvoid delete(Integer i);\n\n/**\n * 更新用户信息\n * @param user\n */\n@Update(\"update user set id=#{id},username=#{username},password=#{password} where id=#{id}\")\nvoid update(User user);\n\n/**\n * 通过id查询用户信息\n * @return\n */\n@Select(\"select * from user where id=#{id}\")\nUser findById(Integer userid);\n\n/**\n * 通过姓名模糊查询\n * @param username\n * @return\n */\n@Select(\"select * from user where username like #{username}\")\nList<User> findByUsername(String username);\n\n~~~\n\n---\n\n\n\n\n\n\n\n\n\n# 一些便于查询和连接的配置\n\n~~~xml\n<configuration>\n    <settings>\n    <!-- 打印查询语句 -->\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\" />\n</settings>\n</configuration>\n-------------------------------------------------------\n<!--静态资源导出问题-->\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n    </resources>\n</build>\n\n<!-- 指定带有dao接口所在位置 -->\n<mappers>\n    <package name=\"com.study.main.dao\"/>\n</mappers>\n\n~~~\n\n', '2020-10-01 16:41:07', 0);
INSERT INTO `tb_blog` VALUES (6, 1, 'Java数据结构与算法', '学习Java数据结构与算法中整理的笔记~~~(持续更新中)', '# 稀疏数组\n\n## **基本介绍**:当一个数组但部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组\n\n#### 稀疏数组的处理方法：\n\n##### 1、记录数组一共有几行几列，有多少个不同的值\n\n##### 2、把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模\n\n##### **案列：**\n\n​            ![image-20200528133318427](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528133318427.png)                   \n\n##### **思路分析**：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528133332816.png\" alt=\"image-20200528133332816\" style=\"zoom:150%;\" />\n\n#### 代码实现：\n\n~~~java\n/**\n * 二维数组转为稀疏数组\n * 稀疏数组转为二维数组\n *\n */\npublic class SparseArray {\n    public static void main(String[] args) {\n        //创建一个原始的二维数组 11 * 11\n        //0：没有棋子  1：黑色棋子  2：蓝色棋子\n        int chessArr1 [][] =new int[11][11];\n        chessArr1[1][2]=1;\n        chessArr1[2][3]=2;\n        chessArr1[5][2]=1;\n        chessArr1[4][8]=2;\n        System.out.println(\"原始的二维数组\");\n        for (int [] row : chessArr1){\n            for (int data : row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n\n        //将二维数组 转 稀疏数组\n        //1、先遍历二维数组 得到非0数据的个数\n        int sum=0;\n        for (int i = 0; i < 11; i++) {\n            for(int j =0;j<11;j++){\n                if (chessArr1[i][j] != 0){\n                    sum++;\n                }\n            }\n        }\n\n        //2、创建对应的稀疏数组\n        int sparseArr[][] = new int[sum+1][3];\n        //给稀疏数组赋值\n        sparseArr[0][0]=11;\n        sparseArr[0][1]=11;\n        sparseArr[0][2]=sum;\n\n        // 遍历二维数组，将非0的值存到sparseArr中\n        int count = 0;\n        for (int i = 0; i < 11; i++) {\n            for(int j=  0;j<11;j++){\n                if (chessArr1[i][j] != 0){\n                    count++;\n                    sparseArr[count][0]=i;\n                    sparseArr[count][1]=j;\n                    sparseArr[count][2]=chessArr1[i][j];\n                }\n            }\n        }\n\n        //输出稀疏数组的形式\n        System.out.println();\n        System.out.println(\"得到的稀疏数组为-----\");\n        System.out.printf(\"行  列  值\");\n        System.out.println();\n        for (int i = 0; i < sparseArr.length; i++) {\n                System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);\n        }\n        System.out.println();\n\n        //稀疏数组恢复为二维数组\n        int chessArr2 [][] = new int [sparseArr[0][0]][sparseArr[0][1]];\n\n        //将数据恢复到二维数组中\n        for (int i=1 ;i<sparseArr.length;i++){\n            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n        }\n        System.out.println();\n        System.out.println(\"恢复后的二维数组\");\n\n        for (int [] row : chessArr2){\n            for (int data : row){\n                System.out.printf(\"%d\\t\",data);\n            }\n            System.out.println();\n        }\n    }\n}\n\n~~~java\n\n\n\n# 队列\n\n### #队列介绍：\n\n###### 1、队列是一个**有序列表，**可以用**数组**或**链表**实现\n\n###### 2、遵循**先入先出**的原则。即：**先存入队列的数据，要先取出。后存入后取出**\n\n### #**数组模拟队列的思路：**\n\n![image-20200528133227355](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528133227355.png)\n\n##### **当我们将数据存入队列是称为“addQueue”的方法需要两个步骤：**\n\n###### **1、** **将尾指针下·往后移：rear+1，当front==rear【空】**\n\n###### **2、** **若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear == maxSize – 1【队列满】**\n\n### #代码实现：\n\n~~~java\npublic class ArrayQueueDemo {\n    public static void main(String[] args) {\n        ArrayQueue arrayQueue = new ArrayQueue(3);\n        char key = \' \';\n        Scanner sc = new Scanner(System.in);\n        boolean loop =true;\n        while (loop){\n            System.out.println(\"s(show)：显示队列\");\n            System.out.println(\"e(exit)：推出程序\");\n            System.out.println(\"a(add)：添加数据到队列\");\n            System.out.println(\"g(get)：从队列中取得数据队列\");\n            System.out.println(\"h(head)：查看队列头的数据\");\n\n            key=sc.next().charAt(0);\n\n            switch (key){\n                case \'s\':\n                    arrayQueue.showQueue();\n                    break;\n                case \'a\':\n                    System.out.println(\"请输入一个数字\");\n                    int value = sc.nextInt();\n                    arrayQueue.addQueue(value);\n                    break;\n                case \'g\':\n                    try {\n                        int res = arrayQueue.getQueue();\n                        System.out.printf(\"取出的数据是%d\\n\",res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'h\':\n                    try {\n                        int res = arrayQueue.headQueue();\n                        System.out.printf(\"队列头部信息是%d\\n\",res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'e\':\n                    sc.close();\n                    loop=false;\n                    break;\n            }\n        }\n        System.out.println(\"程序推出--||--\");\n    }\n}\n//使用数组模拟队列-编写一个ArrayQueue类\nclass ArrayQueue{\n    private int maxSize;//表示数组的最大容量\n    private int front;//队列头\n    private int rear;//队列尾\n    private int[] arr;//该数组用于存放数据，模队列\n\n    //创建队列的构造器\n    public ArrayQueue(int arrMaxSize){\n        maxSize = arrMaxSize;\n        arr = new int [maxSize];\n        front=-1;//指向队列头部，分析出front是指向队列头的前一个位置\n        rear=-1;//指向队列尾，指向队列尾的数据(即就是队列最后一个数据)\n    }\n\n    //判断队列是否已经满\n    public boolean isFull(){\n        return  rear == maxSize - 1;\n    }\n\n    //判断队列是否为空\n    public boolean isEmpty(){\n        return rear == front;\n    }\n\n    //添加数据到队列\n    public void addQueue(int n){\n        //判断队列是否满\n        if (isFull()){\n            System.out.println(\"队列满，不能添加数据\");\n            return;\n        }\n        rear++;//让rear 后移\n        arr[rear] = n;\n    }\n\n    //获取队列数据 出队列\n    public int getQueue(){\n        //判断是否空\n        if (isEmpty()){\n            //通过抛出异常来处理\n            throw new RuntimeException(\"队列空，不能取数据\");\n        }\n        front++; //front后移\n        return arr[front];\n    }\n\n    //显示所有数据\n    public void showQueue(){\n        //遍历\n        if (isEmpty()){\n            System.out.println(\"队列空，无法取得数据\");\n            return;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.printf(\"arr[%d]=%d\\n\",i,arr[i]);\n        }\n    }\n\n    //显示头部数据(不是取出数据)\n    public int headQueue(){\n        //判断\n        if (isEmpty()){\n            throw new RuntimeException(\"队列空，无法取得数据\");\n        }\n        return arr[front + 1];\n    }\n}\n\n~~~\n\n## \n\n#### **问题分析并优化**:\n\n###### **1****、目前数组使用一次就不能再次使用，没有达到复用的效果**\n\n######  **2****、将这个数组使用算法，改进成一个环形的队列 通过取模：%**\n\n\n\n## #**数组模拟环形数列**\n\n###### 思路分析：\n\n![image-20200528133754954](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528133754954.png)\n\n###### 代码实现：\n\n~~~java\n/**\n * 数组模拟环形数列\n */\npublic class circleArrayQueueDemo {\n    public static void main(String[] args) {\n        System.out.println(\"数组模拟环形队列\");\n        //创建一个环形队列\n        circleArray arrayQueue = new circleArray(4);//队列有效数据最大为 arrMaxSize - 1\n        char key = \' \';\n        Scanner sc=new Scanner(System.in);\n        boolean loop = true;\n        while (loop){\n            System.out.println(\"s(show)：显示队列\");\n            System.out.println(\"e(exit)：推出程序\");\n            System.out.println(\"a(add)：添加数据到队列\");\n            System.out.println(\"g(get)：从队列中取得数据队列\");\n            System.out.println(\"h(head)：查看队列头的数据\");\n\n            key=sc.next().charAt(0);\n\n            switch (key){\n                case \'s\':\n                    arrayQueue.showQueue();\n                    break;\n                case \'a\':\n                    System.out.println(\"请输入一个数字\");\n                    int value = sc.nextInt();\n                    arrayQueue.addQueue(value);\n                    break;\n                case \'g\':\n                    try {\n                        int res = arrayQueue.getQueue();\n                        System.out.printf(\"取出的数据是%d\\n\",res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'h\':\n                    try {\n                        int res = arrayQueue.headQueue();\n                        System.out.printf(\"队列头部信息是%d\\n\",res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'e\':\n                    sc.close();\n                    loop=false;\n                    break;\n        }\n\n        }\n        System.out.println(\"程序退出-- || --\");\n    }\n}\n\n//使用数组模拟队列-编写一个ArrayQueue类\nclass circleArray{\n    private int maxSize;//表示数组的最大容量\n    private int front;//指向队列的第一个元素，即arr[front]就是队列的第一个元素  front的初始值=0\n    private int rear;//指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定 rear的初始值=0\n    private int[] arr;//该数组用于存放数据，模队列\n\n    public circleArray(int arrMaxSize){\n        maxSize=arrMaxSize;\n        arr = new int [maxSize];\n    }\n\n    //判断是否满\n    public boolean isFull(){\n        return (rear+1) % maxSize == front;\n    }\n\n    //判断是否空\n    public boolean isEmpty(){\n        return rear == front;\n    }\n\n    //添加数据到队列\n    public void addQueue(int n){\n        //判断队列是否满\n        if (isFull()){\n            System.out.println(\"队列满，不能添加数据\");\n            return;\n        }\n        arr[rear] = n;//直接加入数据\n        rear = (rear+1) % maxSize;//将rear后移 需要考虑取模 防止越界\n    }\n\n    //获取队列数据 出队列\n    public int getQueue(){\n        //判断是否空\n        if (isEmpty()){\n            //通过抛出异常来处理\n            throw new RuntimeException(\"队列空，不能取数据\");\n        }\n        /** front指向队列第一个元素\n         *  1、先把front对应的值保存到一个临时变量\n         *  2、将front后移，考虑取模 防止越界\n         *  3、将临时变量返回\n         */\n        int value = arr[front];\n        front = (front + 1) % maxSize;\n        return value;\n    }\n\n    //求出当前数列有效数据个数\n    public int size(){\n        return (rear + maxSize - front) % maxSize;\n    }\n\n    //显示所有数据\n    public void showQueue(){\n        //遍历\n        if (isEmpty()){\n            System.out.println(\"队列空，无法取得数据\");\n            return;\n        }\n        for (int i = front; i < front + size(); i++) {\n            System.out.printf(\"arr[%d]=%d\\n\",i % maxSize,arr[i%maxSize]);\n        }\n    }\n\n    //显示头部数据(不是取出数据)\n    public int headQueue(){\n        //判断\n        if (isEmpty()){\n            throw new RuntimeException(\"队列空，无法取得数据\");\n        }\n        return arr[front];\n    }\n\n~~~\n\n---\n\n# **链表(Linked List)**\n\n![image-20200528133951229](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528133951229.png)\n\n##### **小结：**\n\n###### **1、** **链表是以节点的方式来存储，是链式储存**\n\n###### **2、** **每个节点包含data域，next域：指向下一个节点**\n\n###### **3、** **如图：发现链表的各个节点不一定是连续存储**\n\n###### **4、** **链表分带头节点的链表和没有头节点的链表，根据实际需求来确定**\n\n\n\n### #**单链表的创建示意图：(不考虑排序)**\n\n![image-20200528134053211](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528134053211.png)\n\n\n\n##### **代码实现(不考虑排序)**\n\n ~~~java\npublic class singleLinkedListDemo {\n    public static void main(String[] args) {\n        HeroNode heroNode1 = new HeroNode(1,\"123\",\"123\");\n        HeroNode heroNode2 = new HeroNode(2,\"456\",\"456\");\n        HeroNode heroNode3 = new HeroNode(3,\"1\",\"1\");\n        HeroNode heroNode4 = new HeroNode(4,\"23\",\"23\");\n\n        //创建要给的链表\n        singleLinkedList singleLinkedList = new singleLinkedList();\n        //加入\n        singleLinkedList.add(heroNode1);\n        singleLinkedList.add(heroNode3);\n        singleLinkedList.add(heroNode2);\n        singleLinkedList.add(heroNode4);\n\n        //目前输出的顺序就时加入数据的顺序\n        singleLinkedList.list();\n    }\n}\n\n//定义singleLinkedList 管理我们的英雄\nclass singleLinkedList{\n    //初始化一个头节点，头节点为固定值,不存放具体的数据\n    private HeroNode head = new HeroNode(0,\"\",\"\");\n\n    //添加节点到单向链表\n    /**\n     * 思路：（不考虑编号时）\n     * 1、找到当前链表的最后一个节点\n     * 2、将最后这个节点的 next 指向新加的节点\n     */\n    public void add(HeroNode heroNode){\n        //因为head节点不能动，因此需要一个辅助遍历temp\n        HeroNode temp = head;\n        //遍历链表，找最后的next\n        while (true){\n            if (temp.next == null){//temp.next值等于空说明找到最后一个值\n                break;\n            }\n            //如果没有找到最后，则将temp后移\n            temp=temp.next;\n        }\n        //当退出了while循环,temp就指向了链表最后\n        //将最后这个节点的next指向 新的节点\n        temp.next = heroNode;\n    }\n\n    //显示链表[遍历]通过一个辅助变量\n    public void list(){\n        //判断链表是否为空\n        if (head.next == null){\n            System.out.println(\"链表为空\");\n            return;\n        }\n        //因为头节点不能动，所以需要一个辅助变量来遍历\n        HeroNode temp = head.next;\n        while (true){\n            //判断链表是否到最后\n            if (temp == null){\n                break;\n            }\n            //输出节点信息\n            System.out.println(temp);\n            //将next后移\n            temp = temp.next;\n        }\n    }\n}\n\n//定义HeroNode，每个HeroNode对应一个节点\nclass HeroNode{\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode next;//指向下一个节点\n    //构造器\n    public HeroNode(int no,String name,String nickname){\n        this.no=no;this.name=name;this.nickname=nickname;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name=\'\" + name + \'\\\'\' +\n                \", nickname=\'\" + nickname + \'\\\'\';\n    }\n}\n\n    \n ~~~\n\n##### 结果—(只按照加入数据得顺序)\n\n![image-20200528134311331](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528134311331.png)\n\n---\n\n### #**单链表创建示意图：(排序)**\n\n![image-20200528134433597](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528134433597.png)\n\n##### **创建新的加入方法(代码实现)**：\n\n~~~java\n/**\n * 第二种添加方式，根据英雄排名将英雄插入到指定位置\n * (如果有这个排名，则添加失败，并给出提示)\n * 因为头节点不能动，需要创建一个变量来找到添加的位置\n * 因为是单链表，因此找的temp位于 添加位置的前一个节点 否则加入不了\n */\npublic void  addByOrder(HeroNode01 heroNode01){\n    HeroNode01 temp = head;\n    boolean flag=false;\n    while (true){\n        if (temp.next == null){//说明temp已经在链表的最后\n            break;\n        }\n        if (temp.next.no > heroNode01.no){//位置找到，就在temp的后面插入\n            break;\n        }else if (temp.next.no == heroNode01.no){//说明添加的heroNode01的编号已经存在\n            flag=true;//编号存在\n            break;\n        }\n        temp = temp.next;//后移，遍历链表\n    }\n    //判断flag的值\n    if (flag){//不能添加，编号已经存在\n        System.out.printf(\"加入的数据编号已经存在%d，不能加入\\n\",heroNode01.no);\n    }else{\n        //插入到链表中，temp的后面\n        heroNode01.next = temp.next;\n        temp.next = heroNode01;\n    }\n}\n\n~~~\n\n### #**更新操作(找到指定的节点值，不能修改节点)**\n\n##### **思路：**\n\n1.**先找到该节点，通过遍历** \n\n2.**temp.name=newheronode.name;temp.nickname=newheronode.nickname;**\n\n###### 代码实现：\n\n~~~java\n/**\n * 修改节点信息，根据no值来修改，所以no值不能修改\n * 根据newHeroNode的no值来修改即可\n * @param newheronode01\n */\n\npublic void update(HeroNode01 newheronode01){\n    //判断是否为空\n    if (head.next == null){\n        System.out.println(\"链表为空\");\n        return;\n    }\n    //找到需要修改的节点，根据no值  定义一个辅助变量\n    HeroNode01 temp = head.next;\n    boolean flag = false;//表示是否找到节点\n    while (true){\n        if (temp == null){\n            break;//已经遍历完链表\n        }\n        if (temp.no == newheronode01.no){\n                flag = true;//找到\n                break;\n        }\n        temp = temp.next;\n    }\n    //根据flag判断是否找到需要修改的节点\n    if (flag){\n        temp.name = newheronode01.name;\n        temp.nickname = newheronode01.nickname;\n    }else{//没有找到\n        System.out.printf(\"没有找到 编号为%d 的节点，不能修改/n\",newheronode01.no);\n\n    }\n}\n\n~~~\n\n### **删除操作**\n\n#### 思路：\n\n![image-20200528135042229](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528135042229.png)\n\n##### 代码实现：\n\n~~~java\n/**\n * 删除节点\n * head不能动。因此需要一个temp辅助节点找到待删除的节点的前一个节点\n * 在比较时，temp.next.no  和 需要删除的节点的no比较\n */\n public void del(int no){\n     HeroNode01 temp =head;\n     boolean flag = false;  //标志是否找到待删除的节点\n     while (true){\n         if (temp.next == null){//已经到了链表的最后\n             break;\n         }\n         if (temp.next.no == no){//找到的待删除的节点的前一个节点temp\n            flag = true;\n            break;\n         }\n         temp = temp.next; //temp后移，遍历\n     }\n     if (flag){//找到，可以删除\n        temp.next = temp.next.next;\n     }else{\n         System.out.printf(\"要删除的 %d 节点不存在/n\",no);\n     }\n }\n\n~~~\n\n## 一些方法的实现：\n\n### 1、获取单链表的节点个数(如果时戴头节点的链表，需求不统计头节点\n\n~~~java\n/**\n * 获取单链表的节点个数(如果时戴头节点的链表，需求不统计头节点)\n * @param head  链表的头节点\n * @return      返回链表有效节点的个数\n */\npublic static int getlength(HeroNode01 head){\n    int len =0;\n    HeroNode01 cur = head.next;\n    if(head.next == null){\n        return 0;\n    }\n    while (cur != null){\n        len++;\n        cur = cur.next;//遍历\n    }\n    return len;\n}\n\n~~~\n\n### 2、查找单链表中的倒数第k个节点\n\n~~~java\n/** 查找单链表中的倒数第k个节点\n * 思路：1、编写方法，接收head节点，index\n *       2、index是表示倒数第index个节点\n *       3、先把链表遍历一遍，得到链表的总长度 (调用getLength()方法即可)\n *       4、得到size后，二次遍历 从链表的第一个到(size-index)个，就可以得到\n *       5、找到返回节点，否则返回null\n * @param head\n * @param index\n * @return\n */\npublic static HeroNode01 getLastIndexNode(HeroNode01 head,int index){\n        if (head.next == null){\n            return null;\n        }\n        //第一次遍历得到链表长度\n        int size = getlength(head);\n        //第二次遍历 size-index 位置，就是倒数第k个节点\n        if (index <=0 || index > size){//校验index在·\n            return null;\n        }\n        //定义辅助变量  for 循环定位到倒数的index\n        HeroNode01 temp = head.next;\n    for (int i = 0; i < size - index; i++) {\n        temp = temp.next;\n    }\n    return temp;\n}\n\n~~~\n\n### 3、将单链表反转\n\n#### **思路分析：**\n\n![image-20200528135257322](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528135257322.png)\n\n#### 代码实现：\n\n~~~java\n**\n *  将单链表反转\n *  思路：1、定义一个节点 reverseHead = new   HeroNode01()\n *        2、将链表遍历一遍，每遍历一个节点 就将其取出 并放在新的链表reverseHead的最前端\n *        3、将原来的链表的head.next = reverseHead.next\n *\n * @param head\n */\npublic static void reverseList(HeroNode01 head){\n    //判断链表是否为空，或者只有一个节点，无需反转直接返回\n    if (head.next == null || head.next.next == null){\n        return;\n    }\n\n    //定义一个辅助的指针(变量)，帮助遍历链表\n    HeroNode01 cur = head.next;\n    HeroNode01 next = null;//指向当前节点【cur】的下一个节点\n    HeroNode01 reverseHead = new HeroNode01(0,\"\",\"\");\n    //遍历原链表，每遍历一个节点将其取出，并放到新的链表reverserHead的最前端\n    while (cur != null){\n        next = cur.next;//暂时保存当前节点的下一个节点\n        cur.next = reverseHead.next;//将cur的下一个节点指向链表的最前端\n        reverseHead.next = cur;//将cur 连接到新的链表上\n        cur = next;//让cur后移\n    }\n    //将head.next 指向 reverser.next ，实现链表的反转\n    head.next = reverseHead.next;\n}\n\n~~~\n\n### 4、逆序打印单链表\n\n#### **思路分析**：\n\n![image-20200528135425219](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528135425219.png)\n\n#### 举例---栈：\n\n~~~java\npublic class TestStack {\n    public static void main(String[] args) {\n        Stack<String> stack = new Stack<String>();\n        //入栈\n        stack.add(\"a\");\n        stack.add(\"b\");\n        stack.add(\"c\");\n\n        //出栈\n        while (stack.size()>0){\n            System.out.println(stack.pop());\n        }\n    }\n}\n~~~\n\n#### 代码实现：\n\n~~~java\n/**\n * 逆序打印单链表\n * 思路：利用栈这个数据结构，将各个节点压入栈中，然后通过栈的先进后出的特点 实现逆序打印\n * @param head\n */\npublic static void reversePrint(HeroNode01 head){\n        if (head.next == null){//链表为空\n            return;\n        }\n    //创建一个栈，将各个节点压入栈中\n    Stack<HeroNode01> stack = new Stack<HeroNode01>();\n    HeroNode01 cur = head.next;\n    while (cur != null){\n        stack.push(cur);\n        cur = cur.next;//cur后移，使得栈可以压入下一个节点\n    }\n    while (stack.size() > 0){//打印逆序后的单链表，通过栈的pop方法\n        System.out.println(stack.pop());\n    }\n}\n~~~\n\n---\n\n## **双向链表：**\n\n### 创建双向链表分析图：\n\n![image-20200528135824800](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528135824800.png)\n\n### **代码实现**：\n\n~~~java\npublic class DoubleLinkedListDemo {\n    public static void main(String[] args) {\n        HeroNode02 heroNode01 = new HeroNode02(1,\"123\",\"123\");\n        HeroNode02 heroNode02 = new HeroNode02(2,\"456\",\"456\");\n        HeroNode02 heroNode03 = new HeroNode02(3,\"1\",\"1\");\n        HeroNode02 heroNode04 = new HeroNode02(4,\"23\",\"23\");\n\n        //创建要给的链表\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\n\n        //添加\n        doubleLinkedList.add(heroNode01);\n        doubleLinkedList.add(heroNode02);\n        doubleLinkedList.add(heroNode03);\n        doubleLinkedList.add(heroNode04);\n\n        doubleLinkedList.list();\n\n        //修改\n        HeroNode02 newheroNode = new HeroNode02(3,\"0\",\"0\");\n        doubleLinkedList.update(newheroNode);\n        System.out.println(\"修改后的链表\");\n        doubleLinkedList.list();\n\n        //删除\n        doubleLinkedList.del(3);\n        System.out.println(\"删除后的链表\");\n        doubleLinkedList.list();\n    }\n}\n\nclass DoubleLinkedList{\n    //先初始化一个头节点 头节点不能动 不存放具体数据\n    private  HeroNode02 head = new HeroNode02(0,\"\",\"\");\n\n    //返回头节点\n    public HeroNode02 getHead(){\n        return head;\n    }\n\n    //遍历双向链表\n    public void list(){\n        //判断链表是否为空\n        if (head.next == null){\n            System.out.println(\"链表为空\");\n            return;\n        }\n        //因为头节点不能动，所以需要一个辅助变量来遍历\n        HeroNode02 temp = head.next;\n        while (true){\n            //判断链表是否到最后\n            if (temp == null){\n                break;\n            }\n            //输出节点信息\n            System.out.println(temp);\n            //将next后移\n            temp = temp.next;\n        }\n    }\n\n    //添加一个节点到双向链表的最后\n    public void add(HeroNode02 heroNode02){\n        //因为head节点不能动，因此需要一个辅助遍历temp\n        HeroNode02 temp = head;\n        //遍历链表，找最后的next\n        while (true){\n            if (temp.next == null){//temp.next值等于空说明找到最后一个值\n                break;\n            }\n            //如果没有找到最后，则将temp后移\n            temp=temp.next;\n        }\n        //当退出了while循环,temp就指向了链表最后\n        //形成一个双向链表\n        temp.next =heroNode02;\n        heroNode02.pre = temp;\n\n    }\n\n    //修改一个节点的内容\n    public void update(HeroNode02 newheronode02){\n        //判断是否为空\n        if (head.next == null){\n            System.out.println(\"链表为空\");\n            return;\n        }\n        //找到需要修改的节点，根据no值  定义一个辅助变量\n        HeroNode02 temp = head.next;\n        boolean flag = false;//表示是否找到节点\n        while (true){\n            if (temp == null){\n                break;//已经找到链表的最后\n            }\n            if (temp.no == newheronode02.no){\n                flag = true;//找到\n                break;\n            }\n            temp = temp.next;\n        }\n        //根据flag判断是否找到需要修改的节点\n        if (flag){\n            temp.name = newheronode02.name;\n            temp.nickname = newheronode02.nickname;\n        }else{//没有找到\n            System.out.printf(\"没有找到 编号为%d 的节点，不能修改/n\",newheronode02.no);\n\n        }\n    }\n\n    /**\n     * 从双向链表中删除一个节点\n     * 说明：1、对于双向链表，可以直接找到需要删除的节点\n     *       2、找到后，自我删除即可\n     * @param no\n     */\n    public void del(int no){\n        //判断链表是否为空\n        if(head.next == null){\n            System.out.println(\"链表为空，无法删除\");\n            return;\n        }\n        HeroNode02 temp =head.next;//辅助变量\n        boolean flag = false;  //标志是否找到待删除的节点\n        while (true){\n            if (temp == null){//已经到了链表的最后\n                break;\n            }\n            if (temp.no == no){//找到的待删除的节点的前一个节点temp\n                flag = true;\n                break;\n            }\n            temp = temp.next; //temp后移，遍历\n        }\n        //判断flag\n        if (flag){\n            temp.pre.next = temp.next;\n            if (temp.next != null){//保证删除的节点不是最后一个节点，否者将出现空指针异常\n                temp.next.pre = temp.pre;\n            }\n        }else{\n            System.out.printf(\"要删除的 %d 节点不存在/n\",no);\n        }\n\n\n    }\n}\n//定义HeroNode02，每个HeroNode02对应一个节点\nclass HeroNode02{\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode02 next;//指向下一个节点 默认为null\n    public HeroNode02 pre;//指向前一个节点  默认为null\n    //构造器\n    public HeroNode02(int no,String name,String nickname){\n        this.no=no;this.name=name;this.nickname=nickname;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name=\'\" + name + \'\\\'\' +\n                \", nickname=\'\" + nickname + \'\\\'\'+\'}\';\n    }\n}\n\n~~~\n\n## **单向链表和双向链表比较**\n\n### **单：**\n\n**	只有一个指向下一个节点的指针**  \n\n​       **优点：增加删除节点简单，遍历时不会死循环**\n\n​       **缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进**\n\n### **双：**\n\n**	有两个指针，一个指向前一个节点，一个指向后一个节点**\n\n​       **优点：可以找到前驱和后继，可进可退**\n\n​       **缺点：增加删除节点复杂，需要多分配一个指针存储空间**\n\n---\n\n## **单向环形链表实现约瑟夫问题：**\n\n### **约瑟夫问题分析**\n\n![image-20200528140116277](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528140116277.png)\n\n### **创建环形链表思路分析图：**\n\n![image-20200528140139893](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528140139893.png)\n\n### **代码实现：**\n\n~~~java\npublic class Josepfu {\n    public static void main(String[] args) {\n        circleSingleLinkedList list = new circleSingleLinkedList();\n        list.add(10);\n        list.showBoy();\n    }\n}\n//创建单向环形链表\nclass circleSingleLinkedList{\n        //创建一个first节点，当前没有编号\n        private Boy first = null;\n\n        //添加节点，构成一个环形链表\n        public void add(int nums){//传入需要添加节点的个数\n            //需要先对nums做校验\n            if (nums <1){\n                System.out.println(\"nums的值不正确\");\n                return;\n            }\n            Boy curBoy = null;//辅助指针，帮助遍历循环\n            //使用for循环来创建环形链表\n            for (int i = 1; i <= nums; i++) {\n                //根据编号，创建节点\n                Boy boy = new Boy(i);\n                //如果是第一个节点\n                if (i == 1){\n                    first = boy;\n                    first.setNext(first);//构成换\n                    curBoy = first;//让curBoy指向第一个节点\n                }else{\n                    curBoy.setNext(boy);\n                    boy.setNext(first);\n                    curBoy = boy;\n                }\n            }\n        }\n\n        //遍历环形链表\n        public void showBoy(){\n            //判断链表是否为空\n            if (first == null){\n                System.out.println(\"链表为空\");\n                return;\n            }\n            Boy curBoy = first;\n            while (true){\n                System.out.printf(\"节点的编号%d\\n\",curBoy.getNo());\n                if (curBoy.getNext() == first){//已经遍历完成\n                    break;\n                }\n                curBoy = curBoy.getNext();\n            }\n        }\n\n}\n//创建一个Boy类，表示一个节点\nclass Boy{\n    private int no;//编号\n    private Boy next;//指向下一个节点，默认为空\n\n    public Boy(int no)  { this.no = no;}\n    public int getNo()  {  return no;}\n    public void setNo(int no) {   this.no = no; }\n    public Boy getNext()   { return next; }\n    public void setNext(Boy next)   {this.next = next;}\n}\n~~~\n\n### **环形链表出圈示意图：**\n\n![image-20200528140318147](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528140318147.png)\n\n### 代码实现：\n\n~~~java\n/**\n * 根据用户输入计算出节点出圈的顺序\n * @param startNo    表示从第几个节点开始数数\n * @param countNum   表示数几下\n * @param nums       表示最初有几个小孩在圈中\n */\n    public void countBoy(int startNo,int countNum,int nums){\n        if (startNo <1 || startNo > nums || first == null){\n            System.out.println(\"输入的参数有误，请重新输入\");\n            return;\n        }\n        //创建一个辅助指针\n        Boy temp = first;\n        //将创建的辅助指针指向环形链表的最后\n        while (true){\n            if (temp.getNext() == first){//说明temp指向最后\n                break;\n            }\n            temp = temp.getNext();\n        }\n        //报数前，让first和temp指针先移动 startNo - 1次\n        for (int i = 0; i < startNo - 1; i++) {\n            first = first.getNext();\n            temp = temp.getNext();\n        }\n        //报数时，让first和temp指针同时移动 countNum - 1次然后出圈，知      道圈中只剩一个节点    \n        while (true){\n            if (temp == first){//只剩一个节点\n                break;\n            }\n            //让first 和 temp 同时移动countNum - 1\n            for (int i = 0; i < countNum - 1; i++) {\n                first = first.getNext();\n                temp = temp.getNext();\n            }\n            //这时first指向的节点就时要出圈的节点\n            System.out.printf(\"节点编号%d出圈\\n\",first.getNo());\n            //这时将first指向的节点出圈\n            first = first.getNext();\n            temp.setNext(first);\n        }\n        System.out.printf(\"最后留在圈中节点编号为%d\\n\",temp.getNo());\n    }\n\n~~~\n\n---\n\n# 栈\n\n### **栈的介绍**：\n\n**1、** **栈是一个****先入后出****的有序链表；**\n\n**2、** **栈是限制性表中元素的插入和删除****只能在线性表的同一端****进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为****栈顶****；另一端为固定的一端，称为****栈底****；**\n\n**3、** **根据定义知：最先放入栈的在栈底，最后放入的在栈顶；而删除时则相反，最后放入的最先删除，最先放入的最后删除；**\n\n### **出栈(pop)和入栈(push)图解：**\n\n![image-20200528142954381](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528142954381.png)\n\n## **数组模拟栈思路分析：**\n\n![image-20200528143126293](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143126293.png)\n\n### **代码实现：**\n\n~~~java\nimport java.util.Scanner;\n\n/**\n * 数组模拟栈\n */\npublic class ArrayStackDemo {\n    public static void main(String[] args) {\n        ArrayStack stack = new ArrayStack(4);\n        String key = \"\";\n        boolean loop = true;\n        Scanner sc = new Scanner(System.in);\n        while (loop){\n            System.out.println(\"show:表示显示栈\");\n            System.out.println(\"exit:退出栈\");\n            System.out.println(\"push:表示加入数据到栈中\");\n            System.out.println(\"pop:表示从栈中取出数据\");\n            System.out.println(\"请输入你的选择\");\n            key = sc.next();\n            switch (key){\n                case \"show\":\n                    stack.list();\n                    break;\n                case \"exit\":\n                    sc.close();\n                    loop = false;\n                    break;\n                case \"push\":\n                    System.out.println(\"请输入你要添加的值\");\n                    int value = sc.nextInt();\n                    stack.push(value);\n                    break;\n                case \"pop\":\n                    try {\n                        int res = stack.pop();\n                        System.out.printf(\"输出的数据是%d\\n\",res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n\n                    break;\n            }\n        }\n        System.out.println(\"程序退出\");\n    }\n}\n\n//定义一个 ArrayStack 表示栈\nclass ArrayStack{\n    private int maxsize;//栈的最大值\n    private int [] stack;//数组  数据存放在该数组\n    private int top = -1;//栈顶 初始值为-1\n\n    public ArrayStack(int maxsize){\n        this.maxsize = maxsize;\n        stack = new int [this.maxsize];\n    }\n\n    //判断栈是否满\n    public boolean isFull(){\n        return top == maxsize-1;\n    }\n\n    //判断栈是否空\n    public boolean isEmpty(){\n        return top == -1;\n    }\n\n    //入栈push\n    public  void push(int value){\n        if (isFull()){\n            System.out.println(\"栈满\");\n            return;\n        }\n        top++;\n        stack[top] = value;\n    }\n\n    //出栈pop\n    public int pop(){\n        if (isEmpty()){\n            throw new RuntimeException(\"栈空，没有数据\");\n        }\n        int value = stack[top];\n        top--;\n        return value;\n    }\n\n    //显示栈\n    public void list(){\n        if (isEmpty()){\n            System.out.println(\"栈空，没有数据\");\n            return;\n        }\n//需要从栈顶开始显示数据\n        for (int i = top; i >=0 ; i--) {\n            System.out.printf(\"stack[%d] = %d\\n\",i,stack[i]);\n        }\n    }\n}\n~~~\n\n## #**栈的应用：(使用栈完成表达式的计算)**\n\n![image-20200528143305734](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143305734.png)\n\n### **代码实现：**\n\n**Bug****：无法存入两位数字**\n\n~~~java\npublic class Calculator {\n    public static void main(String[] args) {\n        String expression = \"3+2*6-2\";\n        //创建连个栈\n        ArrayStack1 numStack = new ArrayStack1(10);//数栈\n        ArrayStack1 operStack = new ArrayStack1(10);//符号栈\n        //定义相关变量\n        int index=0;//用于扫描\n        int num1=0;\n        int num2=0;\n        int oper=0;\n        int res=0;\n        char ch = \' \';//将每次扫描得到的char存到ch中\n        //开始while循环扫描expression\n        while (true){\n            ch = expression.substring(index,index+1).charAt(0);//依次得到每一个字符\n            if (operStack.isOper(ch)){//是运算符\n                if(!operStack.isEmpty()){//判断当前符号栈是否为空\n/** 如果符号栈中有符号则进行比较，\n*   如果当前操作符的优先级小于或等于栈中的操作符，\n*   就需要从数栈中pop出两个数，符号栈中pop出一个符号，\n*   进行运算，得到结果，入数栈，当前符号入符号栈\n                     */\n                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){\n                        num1 = numStack.pop();\n                        num2 = numStack.pop();\n                        oper = operStack.pop();\n                        res = numStack.cal(num1,num2,oper);\n                        numStack.push(res);//把运算结果存入数栈\n                        operStack.push(ch);//把运算符号存入符号栈\n                    }else {\n                        operStack.push(ch);//如果当前操作符的优先级大于栈中的操作符,直接入栈\n                    }\n                }else{//如果为空直接入符号栈\n                        operStack.push(ch);\n                }\n            }\n//无法扫描多位数字\n//------------------------------------------------------\nelse{//如果为数字，直接入栈\n                numStack.push(ch - 48);\n            }\n//------------------------------------------------------\n\n//------------------------------------------------------\n/**  当处理多位数时，需要向expression表达式的后面在看一位，\n *   如果数字就扫描，是符号则入栈。因此需要定义一个变量用于拼接\n */\nelse {\n    keepNum  += ch;\n    if (index == expression.length()-1){\n        numStack.push(Integer.parseInt(keepNum));\n    }else if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){\n        numStack.push(Integer.parseInt(keepNum));\n        keepNum=\"\";//必循将keepNum清空\n    }\n}\n//------------------------------------------------------\n            index++;//让index++，判断是否到expression最后\n            if (index >= expression.length()){\n                break;\n            }\n        }\n\n        //当扫描完后，就顺序从 数栈和符号栈pop出数据进行计算\n        while (true){\n            //如果符号栈为空，则计算到最后的结果，此时数栈只有一个数字就是结果\n            if (operStack.isEmpty()){\n                break;\n            }\n            num1 = numStack.pop();\n            num2 = numStack.pop();\n            oper = operStack.pop();\n            res = numStack.cal(num1,num2,oper);\n            numStack.push(res);//把运算结果存入数栈\n        }\n        int res2 = numStack.pop();\n        System.out.printf(\"表达式%s=%d\",expression,res2);\n    }\n}\n\n//定义一个 ArrayStack 表示栈\nclass ArrayStack1{\n    private int maxsize;//栈的最大值\n    private int [] stack;//数组  数据存放在该数组\n    private int top = -1;//栈顶 初始值为-1\n\n    public ArrayStack1(int maxsize){\n        this.maxsize = maxsize;\n        stack = new int [this.maxsize];\n    }\n\n    //判断栈是否满\n    public boolean isFull(){\n        return top == maxsize-1;\n    }\n\n    //判断栈是否空\n    public boolean isEmpty(){\n        return top == -1;\n    }\n\n    //入栈push\n    public  void push(int value){\n        if (isFull()){\n            System.out.println(\"栈满\");\n            return;\n        }\n        top++;\n        stack[top] = value;\n    }\n\n    //出栈pop\n    public int pop(){\n        if (isEmpty()){\n            throw new RuntimeException(\"栈空，没有数据\");\n        }\n        int value = stack[top];\n        top--;\n        return value;\n    }\n\n    //显示栈\n    public void list(){\n        if (isEmpty()){\n            System.out.println(\"栈空，没有数据\");\n            return;\n        }\n        //需要从栈顶开始显示数据\n        for (int i = top; i >=0 ; i--) {\n            System.out.printf(\"stack[%d] = %d\\n\",i,stack[i]);\n        }\n    }\n\n    //返回栈顶的值，但不是出栈\n    public int peek(){\n        return stack[top];\n    }\n    /**\n     * 返回运算符的优先级，自己来确定，优先级使用数字表示\n     * 数字越大，优先级越高\n     * 目前表达式只有 +，-，*，/\n     */\n     public int priority(int oper){\n        if (oper == \'*\' || oper == \'/\'){\n            return 1;\n        } else if (oper == \'+\' || oper == \'-\') {\n            return 0;\n        }else {\n            return -1;\n        }\n     }\n\n     //判断是否是运算符\n    public boolean isOper(char val){\n         return val==\'+\' || val==\'-\' || val==\'*\' || val==\'/\';\n    }\n\n    //计算方法\n    public int cal(int num1,int num2,int oper){\n        int res = 0;//存放结果\n        switch (oper){\n            case \'+\':\n                res = num1 + num2;\n                break;\n            case \'-\':\n                res = num2 - num1;\n                break;\n            case \'*\':\n                res = num1 * num2;\n                break;\n            case \'/\':\n                res = num2 / num1;\n                break;\n        }\n        return res;\n    }\n}\n~~~\n\n## **前缀，中缀，后缀表达式(逆波兰表达式)**\n\n### **前缀表达式(波兰表达式)：**\n\n**1、**    **前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前**\n\n**2、**    **举例：(3+4)x5-6对应的前缀表达式为： - x + 3 4 5 6**\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143454173.png\" alt=\"image-20200528143454173\" style=\"zoom:150%;\" />\n\n### **中缀表达式：**\n\n**1、**    **中缀表达式就是最常见的运算表达式：(3+4)x5-6;**\n\n**2、**    **计算机在计算中缀表达式时往往会将中缀表达式转   成其他表达式来操作(一般转为后缀表达式)**\n\n### **后缀表达式(逆波兰表达式)：**\n\n**1、**    **后缀表达式又称为逆波兰式，运算符位于数字后面**\n\n**2、**    **举例：(3+4)x5-6 对应的后缀表达式为：3 4 + 5 x 6 –**\n\n**3、**    **再比如：**![image-20200528143558336](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143558336.png)\n\n![image-20200528143613686](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143613686.png)\n\n## **逆波兰计算器实现思路：**\n\n![image-20200528143640125](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200528143640125.png)\n\n### **代码实现：**\n\n~~~java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class PolandNotation {\n    public static void main(String[] args) {\n        //先定义一个逆波兰表达式\n        //(3+4)x5-6 对应的后缀表达式为：3 4 + 5 x 6 –(为了方便数字和符号用空格隔开)\n//        String suffixExpression = \"30 4 + 5 * 6 -\";\n        String suffixExpression = \"4 5 * 8 - 60 + 8 2 / +\";\n        /** 思路：\n         *  1、先将“3 4 + 5 x 6 –” 放到ArrayList中\n         *  2、将ArrayList 传递给一个方法，遍历ArrayList 配合栈 完成计算\n         */\n\n        List<String> list = getStringList(suffixExpression);\n        System.out.println(list);\n        int res = calcuLate(list);\n        System.out.println(\"结果为：\"+res);\n    }\n\n    //将一个逆波兰表达式，一次将数字和符号存入到Array List中\n    public static List<String> getStringList(String suffixExpression){\n        String [] split = suffixExpression.split(\" \");\n        List<String> list  = new ArrayList<String>();\n        for (String ele : split){\n            list.add(ele);\n        }\n        return list;\n    }\n\n    //完成计算\n    public static int calcuLate(List<String> ls){\n        //创建栈，只需要一个即可\n        Stack<String> stack = new Stack<String>();\n        //遍历ls\n        for (String item : ls){\n            //使用正则表达式来取出数\n            if (item.matches(\"\\\\d+\")) {//匹配是多位数\n                stack.push(item);//入栈\n            }else {\n                //pop出两个数进行运算之后再入栈\n                int num2 = Integer.parseInt(stack.pop());\n                int num1 = Integer.parseInt(stack.pop());\n                int res = 0;\n                if (item.equals(\"+\")) res = num1 + num2;\n                else if (item.equals(\"-\")) res = num1 - num2;\n                else if (item.equals(\"*\")) res = num1 * num2;\n                else if (item.equals(\"/\")) res = num1 / num2;\n                else throw new RuntimeException(\"运算符有误\");\n                stack.push(\"\"+res);\n            }\n        }\n        return Integer.parseInt(stack.pop());//\n    }\n}\n~~~\n\n## 中缀转后缀表达式思路分析：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200529111925284.png\" alt=\"image-20200529111925284\" style=\"zoom:200%;\" />\n\n### 代码实现：\n\n~~~java\n主程序：\npublic static void main(String[] args) {\n        /** 完成将一个中缀表达式转后缀表达式得功能\n         *  说明 ： 1、1 + ( ( 2 + 3 ) * 4 - 5 ) =》 转成 1 2 3 + 4 * + 5 -\n         *          2、因为直接操作str不方便，需要将“1 + ( ( 2 + 3 ) * 4 - 5 )” =》 中缀表达式对应的List\n         *          即，“1 + ( ( 2 + 3 ) * 4 - 5 )” =》 ArrayList [1,+,(,(,2,+,3,),*,4,-,5,)]\n         *          3、将得到的中缀表达式的List =》 后缀表达式对应的List\n         *          即，ArrayList[1, +, (, (, 2, +, 3, ), *, 4, -, 5, )] =》 ArrayList[1 , 2 , 3 , + , 4 ,* , + ,5 , -]\n         */\n        String expression = \"1+((2+3)*4)-5\";\n        List<String> ls = toInfixExpressionList(expression);\n        System.out.println(\"中缀表达式为=\"+ls);\n        List<String> list = parseSuffExpressionList(ls);\n        System.out.println(\"后缀表达式为=\"+list);//ArrayList[1 , 2 , 3 , + , 4 ,* , + ,5 , -]\n        System.out.println(calcuLate(list));\n}\n//---------------------------------------------------------------------------------------\n方法：\n    /**\n     * 将 中缀表达式转成对应得list s = \" 1 + ( ( 2 + 3 ) * 4 - 5 )\"\n     * @param s\n     * @return\n     */\n    public static List<String> toInfixExpressionList(String s){\n        //定义一个List，存放中缀表达式 对应得内容\n        List<String> ls = new ArrayList<String>();\n        int i = 0;//辅助指针，用于遍历 中缀表达式字符串\n        String str;//对多位数得拼接\n        char c;//每遍历到一个字符，就放到c中\n        do{\n            //如果是一个数字，加入到ls中\n            if ((c = s.charAt(i))<48 || (c = s.charAt(i)) > 57) {\n                ls.add(\"\"+c);\n                i++;//需要后移，遍历完s\n            }else{//如果是一个数，考虑多位数\n                str=\"\";\n                while (i<s.length() && (c=s.charAt(i)) >=48 && (c=s.charAt(i)) <=57){\n                    str +=c;//拼接\n                    i++;\n                }\n                ls.add(str);\n            }\n\n        }while (i<s.length());\n            return ls;\n    }\n//--------------------------\n    /**\n     *  ArrayList[1, +, (, (, 2, +, 3, ), *, 4, -, 5, )] =》 ArrayList[1 , 2 , 3 , + , 4 ,* , + ,5 , -]\n     *  将得到的中缀表达式的List =》 后缀表达式对应的List\n     * @param ls\n     * @return\n     */\n    public static List<String> parseSuffExpressionList(List<String> ls) {\n        //定义两个栈\n        Stack<String> s1 = new Stack<String>();//符号栈\n        //因为s2这个栈，在整个过程中没有pop操作，而且还需要逆序输出比较麻烦，则用List<String>代替\n        List<String> s2 = new ArrayList<String>();//储存中间结果的List2\n        //遍历ls\n        for (String item : ls) {\n            if (item.matches(\"\\\\d+\")) {//通过正则表达式判断是否为数字\n                s2.add(item);\n            } else if (item.equals(\"(\")) {\n                s1.push(item);\n            } else if (item.equals(\")\")) {\n                //如果为右括号‘）’，依次弹出s1栈顶的运算符，并压入s2，直到遇到‘（’为止，将一对括号丢弃\n                while (!s1.peek().equals(\"(\")) {\n                    s2.add(s1.pop());\n                }\n                s1.pop();//将‘（’弹出s1栈，消除小括号\n            } else {\n                //当item的优先级小于等于s1栈的运算符，将s1栈顶的运算符弹出并加入到s2中，再次与s1中新的栈顶运算符比较\n  while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)) {\n      //栈顶优先级大于item\n                    s2.add(s1.pop());\n                }\n                s1.push(item);\n            }\n        }\n        //将s1中剩余的运算符依次弹出并加入到s2中\n        while (s1.size() != 0 ){\n            s2.add(s1.pop());\n        }\n        return s2;//因为存放到的是List，因此按顺序输出就是对应的后缀表达式对应的List\n    }\n//---------------------------------------------------------------------------------------\n辅助类：\n    //编写一个类，用于返回y运算符对应的优先级\nclass Operation{\n    private static int ADD=1;\n    private static int SUB=1;\n    private static int MUL=2;\n    private static int DIV=3;\n\n    //编写一个方法，返回对应的优先级数字\n    public static int getValue(String operation){\n        int res = 0;\n        switch (operation){\n            case \"+\":\n                res = ADD;\n                break;\n            case \"-\":\n                res = SUB;\n                break;\n            case \"*\":\n                res = MUL;\n                break;\n            case \"/\":\n                res = DIV;\n                break;\n            default:\n                System.out.println(\"没有该运算符\");\n                break;\n        }\n        return res;\n    }\n}\n~~~\n\n---\n\n# 递归\n\n### 递归的概念：\n\n递归就是方法自己调用自己，每次调用时传入不同的变量，**递归有助于编程者解决复炸的问题**，同时使代码变的简洁\n\n### 递归调用机制示意图：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200529152142657.png\" alt=\"image-20200529152142657\" style=\"zoom:200%;\" />\n\n### 递归遵守的重要规则：\n\n1、执行一个方法时，就创建一个新的受保护的独立空间(栈空间)\n\n2、方法的局部变量是独立的，不会相互影响\n\n3、如果方法中使用的是引用变量(比如数组)，就会共享该引用类型的数据\n\n4、递归必**须向退出递归的条件逼近**，否则就是无限递归，出现StackOverflowError，死归了；\n\n5、当一方法执行完毕，或者遇到return，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或			  者返回时，该方法也就执行完毕了\n\n## #迷宫回溯问题：\n\n![image-20200605110730814](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200605110730814.png )\n\n### 代码实现：\n\n走的策略不同，小球的路径也不同。\n\n~~~java\npublic class MiGong {\n    public static void main(String[] args) {\n        //创建一个二维数组，模拟迷宫\n        int [][] map = new int [8][7];\n        //使用1 代表墙\n        //将上下全部置为1\n        for (int i = 0; i < 7; i++) {\n            map[0][i]=1;\n            map[7][i]=1;\n        }\n        //将左右全部置为1\n        for (int i = 0; i < 8; i++) {\n            map[i][0]=1;\n            map[i][6]=1;\n        }\n        map[3][1]=1;\n        map[3][2]=1;\n\n\n        //输出地图\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0;j < 7; j++){\n                System.out.print(map[i][j]+\" \");\n            }\n            System.out.println();\n        }\n\n//        setWay(map,1,1);\n        setWay2(map,1,1);\n        System.out.println(\"找到出路后的地图\");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0;j < 7; j++){\n                System.out.print(map[i][j]+\" \");\n            }\n            System.out.println();\n        }\n    }\n\n    //使用递归回溯来给小球找路\n\n    /** 说明：\n     *  1、map表示地图\n     *  2、i，j表示从地图的哪个位置开始出发\n     *  3、如果小球能找到map[6][5] 的位置，说明找到出路\n     *  4、约定：当map[i][j] 为0时表示该点没有走过；为1时表示墙；\n     *      为2时表示通路可以走；为3表示该点走过，但是不通\n     *  5、在走迷宫时，需要定一个策略(方法)，下->右->上->左,如果该点走不通，在回溯\n     * @param map 表示地图\n     * @param i   表示从哪个位置开始找\n     * @param j\n     * @return  如果找到通路返回true，没有则返回false；\n     */\n    public static boolean setWay(int [][] map ,int i ,int j){\n        if (map[6][5]==2) {//已经找到通路\n            return true;\n        }else{\n            if (map[i][j] == 0){//如果当前这个点还没有走过\n                //按照策略 下->右->上->左\n                map[i][j]=2;//假定该点可以走通\n                    if (setWay(map,i+1,j)) {//向下走\n                    return true;\n                }else if(setWay(map,i,j+1)){//向右走\n                    return true;\n                }else if(setWay(map,i-1,j)){//向上走\n                    return true;\n                }else if(setWay(map,i,j-1)){//向左走\n                    return true;\n                }else{\n                    map[i][j]=3;//说明该点是死了路，走不通\n                    return false;\n                    }\n            }else{//如果map[i][j] ！= 0，可能为1，2，3\n                return false;\n            }\n        }\n    }\n\n    public static boolean setWay2(int [][] map ,int i ,int j){\n        if (map[6][5]==2) {//已经找到通路\n            return true;\n        }else{\n            if (map[i][j] == 0){//如果当前这个点还没有走过\n                //按照策略 上->右->下->左\n                map[i][j]=2;//假定该点可以走通\n                if (setWay2(map,i-1,j)) {//向上走\n                    return true;\n                }else if(setWay2(map,i,j+1)){//向右走\n                    return true;\n                }else if(setWay2(map,i+1,j)){//向下走\n                    return true;\n                }else if(setWay2(map,i,j-1)){//向左走\n                    return true;\n                }else{\n                    map[i][j]=3;//说明该点是死了路，走不通\n                    return false;\n                }\n            }else{//如果map[i][j] ！= 0，可能为1，2，3\n                return false;\n            }\n        }\n    }\n}\n~~~\n\n## #八皇后问题(回溯算法)：\n\n​    ![image-20200605111143758](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200605111143758.png)\n\n### 思路分析：\n\n![image-20200605112431409](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200605112431409.png)\n\n![image-20200605112509990](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200605112509990.png)\n\n### 代码实现：\n\n~~~java\npublic class Queue8 {\n    int max = 8;//定义一个max表示共有多少个皇后\n    static int count=0;\n    static int Judgecount=0;\n    int [] array= new int[max];//定义数组array，保存皇后放置的位置的结果 比如: array={0,4,7,5,2,6,1,3};\n    public static void main(String[] args) {\n        Queue8 queue8 = new Queue8();\n        queue8.check(0);\n        System.out.printf(\"一共有%d种解法\",count);\n        System.out.printf(\"一共有%d次冲突\",Judgecount);\n    }\n\n    //编写一个方法，放置第n个皇后\n    private void check(int n){\n        if(n==max){\n            print();\n            return;\n        }\n        //依次放入皇后，并判断是否冲突\n        for (int i = 0; i < max; i++) {\n            array[n]=i;//先将当前皇后n ， 放置在改行的第一列\n            if (judge(n)){//不冲突，则继续下一个（n + 1）皇后\n                check(n+1);\n            }\n            //如果冲突，就会继续执行array[n] = i;即将第n个皇后，放置在本行的 后移 一个位置\n        }\n    }\n\n    /**\n     *  查看当我们放置第n个皇后，就检测该皇后是否和前面已经摆放的皇后冲突\n     * @param n  表示第n个皇后\n     * @return\n     */\n    private boolean judge(int n){\n        Judgecount++;\n        //没有必要判断是否在同一行，n每次都在递增\n        for (int i = 0; i < n; i++) {\n            //array[i]==array[n]  判断第n个皇后是否和前面一个皇后在同一列\n            //Math.abs(n-i)==Math.abs(array[n] - array[i]  判断第n个皇后是否和前面一个皇后在同一斜线\n            if (array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n] - array[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //将皇后摆放的位置输出\n    private void print(){\n        count++;\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n~~~\n\n# 排序算法(排序)\n\nhttps://www.cnblogs.com/onepixel/articles/7674659.html\n\n## 介绍：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608102026569.png\" alt=\"image-20200608102026569\" style=\"zoom:200%;\" />\n\n## 算法的时间复杂度\n\n### 时间频度：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608104320062.png\" alt=\"image-20200608104320062\" style=\"zoom:200%;\" />\n\n\n\n![image-20200608104744632](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608104744632.png)\n\n\n\n![image-20200608104939427](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608104939427.png)\n\n\n\n <img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608105240657.png\" alt=\"image-20200608105240657\" style=\"zoom:200%;\" />\n\n\n\n### 时间复杂度：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608105851777.png\" alt=\"image-20200608105851777\" style=\"zoom:200%;\" />\n\n\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608110249850.png\" alt=\"image-20200608110249850\" style=\"zoom:200%;\" />\n\n\n\n### 平均时间复杂度和最坏时间复杂度\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608111453122.png\" alt=\"image-20200608111453122\" style=\"zoom:200%;\" />\n\n\n\n## 算法的空间复杂度\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608111838407.png\" alt=\"image-20200608111838407\" style=\"zoom:200%;\" />\n\n\n\n---\n\n## #冒泡排序\n\n### 基本介绍：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608112112111.png\" alt=\"image-20200608112112111\" style=\"zoom:200%;\" />\n\n### 思路图解：\n\n![image-20200608113028539](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200608113028539.png)\n\n### 代码实现：\n\n~~~java\n/**\n * 冒泡排序\n *\n *\n */\npublic class BubbleSort {\n    public static void main(String[] args) {\n        //冒泡排序，时间复杂度O(n^2)\n        int [] arr = {3,9,-1,10,-2};\n        int temp=0;//临时变量存放数据\n        boolean flag = false;//表示变量，判断是否进行过交换\n        System.out.printf(\"原始数组\");\n        System.out.println(Arrays.toString(arr));\n        for (int i = 0; i < arr.length - 1; i++) {\n            for (int j = 0; j <arr.length -1 -i ;j++){\n                if (arr[j] >arr[j+1]) {\n                    flag = true;\n                    temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n            System.out.printf(\"第\"+(i+1)+\"趟排序后的数组\");\n            System.out.println(Arrays.toString(arr));\n            if (!flag){//在一趟排序中，一次都没有发生交换\n                break;\n            }else{\n                flag = false;//重置flag，进行下一次判断\n            }\n        }\n\n    }\n}\n~~~\n\n### 时间比较：\n\n~~~java\npublic static void testtime(){\n        int [] arr = new int [80000];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        bubbleSort(arr);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\n~~~\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200609101556680.png\" alt=\"image-20200609101556680\" style=\"zoom:200%;\" />\n\n---\n\n## #选择排序\n\n### 思路图解：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200609151032544.png\" alt=\"image-20200609151032544\" style=\"zoom:200%;\" />\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Sort;\n/**\n *\n * 选择排序\n *\n */\n\nimport java.util.Arrays;\n\npublic class SelectSort {\n    public static void main(String[] args) {\n        int [] arr = {101,34,119,1};\n        selectSort(arr);\n\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void selectSort(int [] arr){\n        for (int i = 0; i < arr.length - 1; i++) {\n            int minarr = arr[i];\n            int minindex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (minarr>arr[j]) {\n                    minarr = arr[j];\n                    minindex = j;\n                }\n            }\n            if (minindex != i){\n                arr[minindex] = arr[i];\n                arr[i] = minarr;\n            }\n            }\n    }\n}\n~~~\n\n### 时间比较：\n\n~~~java\npublic static void testTime(){\n        int [] arr = new int [80000];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        selectSort(arr);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序后的时间是：\"+date2);\n\n    }\n~~~\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200610141424123.png\" alt=\"image-20200610141424123\" style=\"zoom:150%;\" />\n\n## #插入排序：\n\n### 思路图解：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200610142141754.png\" alt=\"image-20200610142141754\" style=\"zoom:200%;\" />\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Sort;\n\nimport java.util.Arrays;\n\npublic class InsertSort {\n    public static void main(String[] args) {\n        int [] arr = {101,34,119,1,-1,20,30};\n        \n        insertSort1(arr);\n    }\n\n    /**\n     * 分步实现\n     * @param arr\n     */\n    public static void insertSort(int [] arr){\n\n        //定义待插入的数\n		//第一步\n        int insertVal = arr[1];\n        int insertindex = 1-1;//insertVal前一个数的下标\n        /**\n         *  insertindex >= 0 保证插入的数字不越界\n         *  insertVal < arr[insertindex] 待插入的数还没有找到要插入的位置\n         *  需要将arr[insertindex]后移\n         */\n        while (insertindex >= 0 && insertVal < arr[insertindex] ) {\n            arr[insertindex + 1] = arr[insertindex];\n            insertindex--;\n        }\n        //当退出while循环时，说明插入的位置找到，insertindex + 1\n        arr[insertindex+1] = insertVal;\n\n        System.out.println(\"第一轮\");\n        System.out.println(Arrays.toString(arr));\n\n        //第二步\n        insertVal = arr[2];\n        insertindex = 2-1;//insertVal前一个数的下标\n        while (insertindex >= 0 && insertVal < arr[insertindex] ) {\n            arr[insertindex + 1] = arr[insertindex];\n            insertindex--;\n        }\n        //当退出while循环时，说明插入的位置找到，insertindex + 1\n        arr[insertindex+1] = insertVal;\n\n        System.out.println(\"第二轮\");\n        System.out.println(Arrays.toString(arr));\n\n        //第三步\n        insertVal = arr[3];\n        insertindex = 3-1;//insertVal前一个数的下标\n        while (insertindex >= 0 && insertVal < arr[insertindex] ) {\n            arr[insertindex + 1] = arr[insertindex];\n            insertindex--;\n        }\n        //当退出while循环时，说明插入的位置找到，insertindex + 1\n        arr[insertindex+1] = insertVal;\n\n        System.out.println(\"第三轮\");\n        System.out.println(Arrays.toString(arr));\n    }\n\n\n    //小 -> 大\n    public static void insertSort1(int [] arr){\n        for (int i = 1; i < arr.length; i++) {\n            int insertVal = arr[i];\n            int insertindex = i - 1;\n            while (insertindex >= 0 && insertVal < arr[insertindex]) {\n                arr[insertindex + 1] = arr[insertindex];\n                insertindex--;\n            }\n            //优化\n            if (insertindex + 1 != i){\n                arr[insertindex+1] = insertVal;\n            }\n//            System.out.println(\"第\"+i+\"轮\");\n//            System.out.println(Arrays.toString(arr));\n        }\n    }\n\n    //大 -> 小\n    public static void insertSort2(int [] arr){\n        for (int i = 1; i < arr.length; i++) {\n            int insertVal = arr[i];\n            int insertindex = i - 1;\n            while (insertindex >= 0 && insertVal > arr[insertindex]) {\n                arr[insertindex + 1] = arr[insertindex];\n                insertindex--;\n            }\n            //优化\n            if (insertindex + 1 != i){\n                arr[insertindex+1] = insertVal;\n            }\n//            System.out.println(\"第\"+i+\"轮\");\n//            System.out.println(Arrays.toString(arr));\n        }\n    }\n}\n\n~~~\n\n### 时间比较：\n\n~~~java\npublic static void main(String[] args) {\n//        int [] arr = {101,34,119,1,-1,20,30};\n        int [] arr = new int [80000];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        insertSort1(arr);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\npublic static void insertSort1(int [] arr){\n        for (int i = 1; i < arr.length; i++) {\n            int insertVal = arr[i];\n            int insertindex = i - 1;\n            while (insertindex >= 0 && insertVal < arr[insertindex]) {\n                arr[insertindex + 1] = arr[insertindex];\n                insertindex--;\n            }\n            arr[insertindex+1] = insertVal;\n//            System.out.println(\"第\"+i+\"轮\");\n//            System.out.println(Arrays.toString(arr));\n        }\n    }\n~~~\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200610152946606.png\" alt=\"image-20200610152946606\" style=\"zoom:150%;\" />\n\n### 存在的问题：	\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612141132177.png\" alt=\"image-20200612141132177\" style=\"zoom:150%;\" />\n\n## #希尔排序：\n\n### 示意图：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612141655769.png\" alt=\"image-20200612141655769\" style=\"zoom:150%;\" />\n\n### 应用实例：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612142018988.png\" alt=\"image-20200612142018988\" style=\"zoom:150%;\" />\n\n## #希尔排序----交换法：\n\n### 代码实现：\n\n~~~java\n//对有序序列在插入时采用交换法\n	public class ShellSort {\n    public static void main(String[] args) {\n        int [] arr = {8,9,1,7,2,3,5,4,6,0};\n\n//        shellSort(arr);\n\n        shellSort1(arr);\n    }\n\n    //逐步推导编写希尔排序\n    //插入时交换的方法\n    public static void shellSort(int [] arr){\n        int temp =0;\n        //希尔排序的第一轮\n        //因为希尔排序第一轮将10个数据分成了5组 (arr.length/2)\n        for (int i = 5; i < arr.length; i++) {\n            //遍历各组中所有的元素(共五组，每组两个元素)，步长5\n            for (int j = i - 5;j>=0;j -= 5){\n                if (arr[j] > arr[j+5]){\n                    //如果当前元素大于加上步长后的那个元素，说明需要交换\n                    temp = arr[j];\n                    arr[j]=arr[j+5];\n                    arr[j+5]=temp;\n                }\n            }\n        }\n        System.out.println(\"希尔排序第一轮：\"+ Arrays.toString(arr));\n\n        for (int i = 2; i < arr.length; i++) {\n            for (int j = i -2;j>=0;j -=2){\n                if (arr[j] > arr[j+2]){\n                    temp = arr[j];\n                    arr[j]=arr[j+2];\n                    arr[j+2]=temp;\n                }\n            }\n        }\n        System.out.println(\"希尔排序第二轮：\"+ Arrays.toString(arr));\n\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i -1;j>=0;j -=1){\n                if (arr[j] > arr[j+1]){\n                    temp = arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=temp;\n                }\n            }\n        }\n        System.out.println(\"希尔排序第三轮：\"+ Arrays.toString(arr));\n    }\n\n    //插入时交换的方法\n    public static void shellSort1(int [] arr){\n        int temp = 0;\n        for (int gap = arr.length / 2;gap>0;gap /=2){\n            for (int i = gap; i < arr.length; i++) {\n                for (int j = i -gap;j>=0;j -=gap){\n                    if (arr[j] > arr[j+gap]){\n                        //如果当前元素大于加上步长后的那个元素，说明需要交换\n                        temp = arr[j];\n                        arr[j]=arr[j+gap];\n                        arr[j+gap]=temp;\n                    }\n                }\n            }\n        }\n        System.out.println(Arrays.toString(arr));\n    }\n}\n~~~\n\n### 时间比较：\n\n~~~java\npublic static void testTime(){\n        int [] arr = new int [80000];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        shellSort1(arr);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\n~~~\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612145646222.png\" alt=\"image-20200612145646222\" style=\"zoom:150%;\" />\n\n### 弊端：\n\n发现一组数据再进行交换，时间变得更加长\n\n## #希尔排序----移位法：\n\n### 代码实现：\n\n~~~java\n//对交换式排序的希尔排序进行优化-->移位法\n    public static void shellSort2(int [] arr){\n        //增量gap，并逐步减小增量\n        for (int gap = arr.length;gap > 0;gap /=2){\n            //从第gap个元素，逐个对其所在组进行直接插入排序\n            for (int i = gap; i < arr.length; i++) {\n                int j =i;\n                int temp = arr[i];\n                if (arr[j] < arr[j-gap]) {\n                    while (j - gap >=0 && temp < arr[j-gap]) {\n                        //移动\n                        arr[j]=arr[j-gap];\n                        j -= gap;\n                    }\n                    //当退出while循环，就给temp找到插入的位置\n                    arr[j]=temp;\n                }\n            }\n        }\n    }\n~~~\n\n### 时间比较：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612152832009.png\" alt=\"image-20200612152832009\" style=\"zoom:150%;\" />\n\n## #快速排序：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612153337924.png\" alt=\"image-20200612153337924\" style=\"zoom:150%;\" />\n\n### 思路分析：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612154214686.png\" alt=\"image-20200612154214686\" style=\"zoom:150%;\" />\n\n### 算法描述：\n\n**快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：**\n\n1. **从数列中挑出一个元素，称为 “基准”（pivot）；**\n2. **重新排序数******列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；****\n3. **递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。**\n\n### 代码实现：\n\n~~~java\nimport java.io.PipedOutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.PrimitiveIterator;\n\n/**\n * 快速排序\n *\n */\n\npublic class QuickSort {\n    public static void main(String[] args) {\n        int [] arr = {-9,78,0,23,-567,70,-5,489};\n        quickSort(arr,0,arr.length-1);\n        System.out.println(Arrays.toString(arr));\n\n//        testTime();\n    }\n\n    public static void quickSort(int [] arr,int left,int right){\n        int l = left;\n        int r = right;\n        int pivot = arr[(left+right) / 2];//中轴值\n        int temp = 0;//临时变量\n        //while循环的目的是把比pivot小的值 放到pivot的左边\n        while (l < r){\n            //在pivot的左边一直找，找到大于等于pivot的值才退出\n            while(arr[l] < pivot){\n                l +=1;\n            }\n            //在pivot的右边一直找，找到小于等于pivot的值才退出\n            while (arr[r] > pivot){\n                r -=1;\n            }\n            /**\n             *  如果 l >= r 说明pivot的左右值，已经按照\n             *  左边全部小于等于pivot，右边全部大于等于pivot\n             */\n            if (l >= r){\n                break;\n            }\n            //交换\n            temp = arr[l];\n            arr[l]=arr[r];\n            arr[r]=temp;\n\n            //如果交换完后 发现arr[l] == pivot的值  r--，前移\n            if (arr[l] == pivot){\n                r -= 1;\n            }\n            //如果交换完后 发现arr[r] == pivot的值  l++，后移\n            if (arr[r] == pivot){\n                l += 1;\n            }\n        }\n        // 如果 l == r ，必须l++    r-- ,否则会出现栈溢出\n        if (l == r){\n            l +=1;\n            r -=1;\n        }\n        //向左递归\n        if(left < r){\n            quickSort(arr,left,r);\n        }\n        //向右递归\n        if(right > r){\n            quickSort(arr,l,right);\n        }\n    }\n\n//测试时间方法\n    public static void testTime(){\n        int [] arr = new int [80000];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        quickSort(arr,0,arr.length-1);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\n}\n~~~\n\n### 时间比较：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200612162037824.png\" alt=\"image-20200612162037824\" style=\"zoom:150%;\" />\n\n## #归并排序：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200622144457954.png\" alt=\"image-20200622144457954\" style=\"zoom:150%;\" />\n\n### 思路分析：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200628143317878.png\" alt=\"image-20200628143317878\" style=\"zoom:200%;\" />\n\n### 代码实现：\n\n~~~java\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\n\npublic class MergerSort {\n    public static void main(String[] args) {\n        int [] arr = {8,4,5,7,1,3,6,2};\n        int [] temp = new int[arr.length];\n        mergersort(arr,0,arr.length-1,temp);\n        System.out.println(Arrays.toString(arr));\n//        testTime();\n    }\n\n    //分+合的方法\n    public static void mergersort(int [] arr,int left,int right,int [] temp){\n        if (left <right){\n            int mid = (left+right) / 2;//中间索引\n            //向左递归进行分解\n            mergersort(arr,left,mid,temp);\n            //向有递归进行分解\n            mergersort(arr,mid+1,right,temp);\n            //合并\n            merge(arr,left,mid,right,temp);\n        }\n    }\n    /**\n     *  合并的方法\n     * @param arr   排序的原始数组\n     * @param left  左边有数序列的初始索引\n     * @param mid   中间索引\n     * @param right 右边索引\n     * @param temp  做中转的数组\n     */\n    public static void merge(int [] arr,int left,int mid,int right,int [] temp){\n        int i = left;  //初始化i，左边有序数列的初始索引\n        int j = mid+1; //初始化j，右边有序数列的初始索引\n        int t = 0;     //指向temp数组的当前索引\n\n        /**\n         一、\n            先把左右两边(有序)的数据按照规则填充到temp数组\n            直到左右两边的有序序列，有一边处理完毕为止\n         */\n        while (i<=mid && j<=right){\n            /**如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素\n               即将左边的当前元素，填充到temp数组中。然后后移 即t++ i++  */\n            if (arr[i] <= arr[j]){\n                temp[t]=arr[i];\n                t +=1;\n                i +=1;\n            }else{//反之，将右边有序序列的当前元素，填充到temp数组\n                temp[t]=arr[j];\n                t +=1;\n                j +=1;\n            }\n        }\n\n        /**\n         二、\n            把有剩余数据的一边的数据依次全部填充到temp\n         */\n        //左边有序序列有剩余元素，就全部填充到temp数组中\n        while (i <= mid){\n            temp[t]=arr[i];\n            t +=1;\n            i +=1;\n        }\n        //右边有序序列有剩余元素，就全部填充到temp数组中\n        while (j <= right){\n            temp[t]=arr[j];\n            t +=1;\n            j +=1;\n        }\n\n        /**\n         三、\n            将temp数组的元素拷贝到arr，并不是每次都拷贝所有\n         */\n        t = 0;\n        int tempLeft = left;\n        //第一次合并 tempLeft=0，t=1；二 tempLeft=2，t=3；三 tempLeft=0，t=3\n        // 最后一次 tempLeft=0，t=arr.length-1；\n//        System.out.println(\"tempLeft=\"+tempLeft + \"right=\" + right);\n        while (tempLeft <= right){\n            arr[tempLeft] = temp[t];\n            t +=1;\n            tempLeft +=1;\n        }\n    }\n\n    //时间测试\n    public static void testTime(){\n        int [] arr = new int [80000];\n        int [] temp = new int[arr.length];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        mergersort(arr,0,arr.length-1,temp);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\n}\n\n~~~\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200628151802345.png\" alt=\"image-20200628151802345\" style=\"zoom:100%;\" />\n\n### 时间比较：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200628151910615.png\" alt=\"image-20200628151910615\" style=\"zoom:150%;\" />\n\n## #基数排序(桶排序)：\n\n### 介绍：\n\n![image-20200705160704485](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705160704485.png)\n\n### 思路分析：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705172610074.png\" alt=\"image-20200705172610074\" style=\"zoom:150%;\" />![image-20200705172656725](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705172656725.png)\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705172724072.png\" alt=\"image-20200705172724072\" style=\"zoom:150%;\" />\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705172849425.png\" alt=\"image-20200705172849425\" style=\"zoom:150%;\" />\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Sort;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\n\n/**\n * 基数排序是使用空间换时间的经典算法\n *\n */\npublic class RadixSort {\n    public static void main(String[] args) {\n        int [] arr = {53,3,542,748,14,214};\n//        radixSortTest(arr);\n//        radixSort(arr);\n            testTime();\n    }\n\n    //基数排序\n    public static void radixSortTest(int [] arr){\n        /** 定义一个二维数组，表示10个桶，每个桶就是一个一维数组\n            二维数组包含10个一维数组，为了防止放数据的时候，数据溢出\n            每一个一维数组的大小定义为arr.length\n         */\n        int [][] bucket = new int [10][arr.length];\n        //定义一个一维数组，用来记录实际存放了多少个数据\n        int [] bucketCount = new int [10];\n\n        //第一轮(针对每个元素的个位进行排序处理)\n        for (int j = 0;j<arr.length;j++){\n            int bitElement = arr[j] % 10;\n            bucket[bitElement][bucketCount[bitElement]] = arr[j];\n            bucketCount[bitElement]++;\n        }\n        //按照这个桶的顺序(一维数组的数据依次取出数据，放回到原来数组)\n        int index = 0;\n        //遍历每一个桶，并将有数据的桶中的元素，放回到原来的数组中\n        for (int k = 0;k<bucketCount.length;k++){\n            //如果桶中有数据才放入原数组\n            if (bucketCount[k] != 0 ){\n                //循环该桶即第k个桶(即第k个一维数组)\n                for (int l = 0;l<bucketCount[k];l++){\n                    //取出元素放到arr中\n                    arr[index]=bucket[k][l];\n                    index++;\n                }\n            }\n            //第一轮处理后，需要将每个bucketCount[k]置为0\n            bucketCount[k] = 0;\n        }\n        System.out.println(\"第一轮处理后的arr：\"+Arrays.toString(arr));\n\n//=================================================\n\n        //第二轮(针对每个元素的个位进行排序处理)\n        for (int j = 0;j<arr.length;j++){\n            int bitElement = arr[j] /10 % 10;\n            bucket[bitElement][bucketCount[bitElement]] = arr[j];\n            bucketCount[bitElement]++;\n        }\n        //按照这个桶的顺序(一维数组的数据依次取出数据，放回到原来数组)\n        index = 0;\n        //遍历每一个桶，并将有数据的桶中的元素，放回到原来的数组中\n        for (int k = 0;k<bucketCount.length;k++){\n            //如果桶中有数据才放入原数组\n            if (bucketCount[k] != 0 ){\n                //循环该桶即第k个桶(即第k个一维数组)\n                for (int l = 0;l<bucketCount[k];l++){\n                    //取出元素放到arr中\n                    arr[index]=bucket[k][l];\n                    index++;\n                }\n            }\n            //第二轮处理后，需要将每个bucketCount[k]置为0\n            bucketCount[k] = 0;\n        }\n        System.out.println(\"第二轮处理后的arr：\"+Arrays.toString(arr));\n\n//================================================\n\n        //第三轮(针对每个元素的个位进行排序处理)\n        for (int j = 0;j<arr.length;j++){\n            int bitElement = arr[j] /100 % 10;\n            bucket[bitElement][bucketCount[bitElement]] = arr[j];\n            bucketCount[bitElement]++;\n        }\n        //按照这个桶的顺序(一维数组的数据依次取出数据，放回到原来数组)\n        index = 0;\n        //遍历每一个桶，并将有数据的桶中的元素，放回到原来的数组中\n        for (int k = 0;k<bucketCount.length;k++){\n            //如果桶中有数据才放入原数组\n            if (bucketCount[k] != 0 ){\n                //循环该桶即第k个桶(即第k个一维数组)\n                for (int l = 0;l<bucketCount[k];l++){\n                    //取出元素放到arr中\n                    arr[index]=bucket[k][l];\n                    index++;\n                }\n            }\n            //第三轮处理后，需要将每个bucketCount[k]置为0\n            bucketCount[k] = 0;\n        }\n        System.out.println(\"第三轮处理后的arr：\"+Arrays.toString(arr));\n\n    }\n    public static void radixSort(int [] arr){\n        //得到最大的数的位数\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i]>max){\n                max = arr[i];\n            }\n        }\n        //得到最大数的是几位数\n        int maxLength = (max+\"\").length();\n        int [][] bucket = new int [10][arr.length];\n        int [] bucketCount = new int [10];\n        for (int i = 0,n = 1; i < maxLength; i++,n *= 10) {\n            for (int j = 0;j<arr.length;j++){\n                int bucketElement = arr[j] / n % 10;\n                bucket[bucketElement][bucketCount[bucketElement]] = arr[j];\n                bucketCount[bucketElement]++;\n            }\n            int index = 0;\n            for (int k =0;k<bucketCount.length;k++){\n                if (bucketCount[k] != 0){\n                    for (int l =0;l<bucketCount[k];l++){\n                        arr[index]=bucket[k][l];\n                        index++;\n                    }\n                }\n                bucketCount[k] = 0;\n            }\n//            System.out.println(\"第\"+i+\"轮排序后arr：\"+Arrays.toString(arr));\n        }\n//        System.out.println(\"排序后arr：\"+Arrays.toString(arr));\n    }\n\n    //时间测试\n    public static void testTime(){\n        int [] arr = new int [80000];\n        int [] temp = new int[arr.length];\n        for (int i = 0; i < 80000; i++) {\n            arr[i] = (int) (Math.random() * 80000);\n        }\n        Date date1 = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String str1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序前的时间是：\"+date1);\n\n        radixSort(arr);\n\n        Date date2 = new Date();\n        String str2 = simpleDateFormat.format(date2);\n        System.out.println(\"排序前的时间是：\"+date2);\n    }\n}\n\n~~~\n\n### 时间比较：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705173004309.png\" alt=\"image-20200705173004309\" style=\"zoom:150%;\" />\n\n#### 注意点：\n\n1. 基数排序是对传统桶排序的扩展，速度很快\n\n2. 基数排序是经典的空间换时间的算法，占用内存较大，当对海量数据排序时，容易造成 OutOfMemoryError\n\n   <img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200705173504857.png\" alt=\"image-20200705173504857\" style=\"zoom:150%;\" />\n\n# 查找算法：\n\n## #线性(顺序)查找：\n\n### 代码实现：\n\n~~~java\npublic class SeqSearch {\n    public static void main(String[] args) {\n        int [] arr = {12,43,-12,4,67,8};\n        int index = seqSearch(arr,-12);\n        if (index == -1){\n            System.out.println(\"没有找到\");\n        }else{\n            System.out.println(\"找到了下标为：\"+index);\n        }\n    }\n    public static int seqSearch(int [] arr,int value){\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == value){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n~~~\n\n## #二分查找：\n\n### 思路分析：\n\n![image-20200723111955678](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200723111955678.png)\n\n### 数组必须为有序数组！！！\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Search;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BinarySearch {\n    public static void main(String[] args) {\n        int [] arr = {1,8,10,89,1000,1000,1000,1000,1234};\n//        int resindex = binarySearch(arr,0,arr.length-1,8);\n//        System.out.println(resindex);\n        List list = binarySearch2(arr,0,arr.length-1,1000);\n        System.out.println(list);\n\n\n    }\n\n    /**\n     *\n     * @param arr      数组\n     * @param left     左索引\n     * @param right    右索引\n     * @param findval  要查找得值\n     * @return\n     */\n    public static int binarySearch(int [] arr,int left,int right,int findval){\n        //如果 left > right时，说明递归整个数组，但是没有找到\n        if (left > right){\n            return -1;\n        }\n        int mid = (left + right) / 2;\n        int midval = arr[mid];\n        if (findval > midval){// 向 右 递归\n            return binarySearch(arr,mid + 1,right,findval);\n        }else if (findval < midval){// 向 左 递归\n            return binarySearch(arr,left,mid - 1,findval);\n        }else{\n            return mid;\n        }\n    }\n\n    /**\n     当一个有序数组中有多个相同的值时，如何将所有的值都查找到并返回下标\n        思路分析：\n            1、在找到mid索引值，不要马上返回\n            2、向mid值索引值的左边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            3、向mid值索引值的右边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            4、将ArrayList返回\n\n     */\n    public static List<Integer> binarySearch2(int [] arr,int left,int right,int findval){\n        //如果 left > right时，说明递归整个数组，但是没有找到\n        if (left > right){\n            return new ArrayList<Integer>();\n        }\n        int mid = (left + right) / 2;\n        int midval = arr[mid];\n        if (findval > midval){// 向 右 递归\n            return binarySearch2(arr,mid + 1,right,findval);\n        }else if (findval < midval){// 向 左 递归\n            return binarySearch2(arr,left,mid - 1,findval);\n        }else{\n            List<Integer> list = new ArrayList<>();\n//            向mid值索引值的左边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            int temp = mid - 1;\n            while (true){\n                if (temp < 0 || arr[temp] != findval){\n                    break;\n                }\n                //否则temp 放到list\n                list.add(temp);\n                temp -= 1;\n            }\n                list.add(mid);\n\n//            向mid值索引值的右边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            temp = mid + 1;\n            while (true){\n                if (temp > arr.length - 1 || arr[temp] != findval){\n                    break;\n                }\n                //否则temp 放到list\n                list.add(temp);\n                temp += 1;\n            }\n            return list;\n        }\n    }\n}\n\n~~~\n\n## #插值查找：\n\n### 思路分析：\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200727143107284.png\" alt=\"image-20200727143107284\" />\n\n![image-20200727143140081](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200727143140081.png)\n\n### 注意点：\n\n1. 对于数据量大，关键字分布比较均匀的情况下，采用插值查找，速度较快\n2. 关键字分布不均匀的情况下，该方法不一定比折半查找方法好\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Search;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class InsertValueSearch {\n    public static void main(String[] args) {\n        int [] arr = new int [100];\n        for (int i = 0; i < 100; i++) {\n            arr[i] =  i + 1;\n        }\n        System.out.println(Arrays.toString(arr));\n    }\n\n\n    /**\n     *\n     * @param arr\n     * @param left\n     * @param right\n     * @param findVal\n     * @return\n     */\n    public static int insertValueSearch(int [] arr,int left,int right,int findVal){\n        //注意：findVal < arr[0] 和 findVal > arr[arr.length - 1] 是必须的不然求出的mid可能越界\n        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]){\n            return -1;\n        }\n        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n        int midVal = arr[mid];\n        if (findVal > midVal){\n            return insertValueSearch(arr,mid+1,right,findVal);\n        }else if (findVal < midVal){\n            return insertValueSearch(arr,left,mid-1,findVal);\n        }else {\n            return mid;\n        }\n    }\n\n    \n    public static List<Integer> insertValueSearch2(int [] arr, int left, int right, int findVal){\n        //注意：findVal < arr[0] 和 findVal > arr[arr.length - 1] 是必须的不然求出的mid可能越界\n        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]){\n            new ArrayList<Integer>();\n        }\n        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n        int midVal = arr[mid];\n        if (findVal > midVal){\n            return insertValueSearch2(arr,mid+1,right,findVal);\n        }else if (findVal < midVal){\n            return insertValueSearch2(arr,left,mid-1,findVal);\n        }else{\n            List<Integer> list = new ArrayList<>();\n//            向mid值索引值的左边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            int temp = mid - 1;\n            while (true){\n                if (temp < 0 || arr[temp] != findVal){\n                    break;\n                }\n                //否则temp 放到list\n                list.add(temp);\n                temp -= 1;\n            }\n            list.add(mid);\n\n//            向mid值索引值的右边扫描，将所有满足1000的元素下标，加入到集合ArrayList\n            temp = mid + 1;\n            while (true){\n                if (temp > arr.length - 1 || arr[temp] != findVal){\n                    break;\n                }\n                //否则temp 放到list\n                list.add(temp);\n                temp += 1;\n            }\n            return list;\n        }\n    }\n}\n\n~~~\n\n## #斐波那契(黄金分割法)查找：	\n\n### 介绍：\n\n![image-20200727155900118](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200727155900118.png)\n\n### 思路分析：\n\n![image-20200727160025413](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200727160025413.png )\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Search;\n\nimport java.util.Arrays;\n\npublic class FibonacciSearch {\n    public static int maxsize = 20;\n    public static void main(String[] args) {\n        int [] arr = {1,8,10,89,1000,1234};\n\n        System.out.println(fibSearch(arr,1234));\n    }\n    //mid = low + F[k-1]-1,需要使用到斐波那契数列\n    //非递归的方法得到一个斐波那契数列\n    public static int [] fib(){\n        int [] f = new int [maxsize];\n        f[0] = 1;\n        f[1] = 1;\n        for (int i = 2; i < maxsize; i++) {\n            f[i] = f[i-1]+f[i-2];\n        }\n        return f;\n    }\n\n    /**\n     *  编写斐波那契查找算法(使用非递归写算法)\n     * @param a   数组\n     * @param key 需要查找的关键码(值)\n     * @return    返回对应下标，没有则返回-1\n     */\n    public static int fibSearch (int [] a,int key){\n        int low = 0;\n        int high= a.length - 1;\n        int k =0; //表示斐波那契分割数值的下标\n        int mid = 0;//存放中间值\n        int [] f = fib();//获得斐波那契数列\n        //获取斐波那契分割数值的下标\n        while (high > f[k] - 1){\n            k++;\n        }\n        //因为 f[k] 值可能大于a的长度，因此需要使用Arrays类 构造一个新的数组，并指向a[]\n        //不足的部分会使用0填充\n        int [] temp = Arrays.copyOf(a,f[k]);\n        //实际上需求使用a数组最后的数填充temp\n        //eg：temp = {1,8,10,89,1000,1234,0,0,0} => {1,8,10,89,1000,1234,1234,1234,1234}\n        for (int i = high+1; i < temp.length; i++) {\n            temp[i] = a[high];\n        }\n\n        //使用while来循环处理，找到我们的数key\n        while(low <= high){\n            mid = low + f[k-1] -1;\n            if (key < temp[mid]){ //需要向数组的前面查找(左边)\n                high = mid - 1;\n                k--;\n                /*  k--\n                    1、全部元素 = 前面元素 + 后边元素\n                    2、f[k] = f[k-1] + f[k-2];\n                    3、因为后面有f[k-2]所以可以继续拆分f[k-1] = f[k-2] + f[k-3];\n                    4、即在f[k-1]的前面继续查找 k--;\n                    5、即下次循环 mid = f[k-1-1] - 1;\n                 */\n            }else if (key > temp[mid]){//需要向数组的后面查找(右边)\n                low = mid + 1;\n                k -=2;\n                /*  k -=2\n                    1、全部元素 = 前面元素 + 后边元素\n                    2、f[k] = f[k-1] + f[k-2];\n                    3、因为后面有f[k-2]所以可以继续拆分f[k-1] = f[k-3] + f[k-4];\n                    4、即在f[k-2]的前面继续查找 k -=2;\n                    5、即下次循环 mid = f[k-1-2] - 1;\n                 */\n            }else{ //找到\n                //需要确定返回的是哪个下标\n                if(mid <= high){\n                    return mid;\n                }else {\n                    return high;\n                }\n            }\n        }\n            return -1;\n    }\n}\n~~~\n\n# 哈希表：\n\n![image-20200809160830025](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809160830025.png)\n\n## 哈希表的基本介绍：\n\n![image-20200809160918202](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809160918202.png)\n\n\n\n![image-20200809160950800](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809160950800.png)\n\n## 示例题：\n\n![image-20200809161147431](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809161147431.png)\n\n## 思路分析：\n\n![image-20200809161222011](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809161222011.png)\n\n## 代码实现：\n\n~~~java\nimport java.util.Scanner;\npublic class HashTabDemo {\n    public static void main(String[] args) {\n\n        HashTab hashTab = new HashTab(7);\n\n        String key = \"\";\n        Scanner scanner = new Scanner(System.in);\n        while (true){\n            System.out.println(\"add： 添加雇员\");\n            System.out.println(\"list：显示雇员\");\n            System.out.println(\"find：查找雇员\");\n            System.out.println(\"exit：退出系统\");\n\n            key = scanner.next();\n            switch (key){\n                case \"add\":\n                    System.out.println(\"请输入id\");\n                    int id = scanner.nextInt();\n                    System.out.println(\"请输入姓名\");\n                    String name = scanner.next();\n                    Emp emp = new Emp(id,name);\n                    hashTab.add(emp);\n                    break;\n                case \"list\":\n                    hashTab.list();\n                    break;\n                case \"find\":\n                    System.out.println(\"请输入要找找的id号\");\n                    int findId = scanner.nextInt();\n                    hashTab.findEmpById(findId);\n                    break;\n                case \"exit\":\n                    scanner.close();\n                    System.exit(0);\n                default:\n                    break;\n            }\n        }\n    }\n}\nclass HashTab{//创建HashTab 管理多条链表\n    private EmpLinkedList [] empLinkedListArray;\n    private int size;//表示有多少条链表\n\n    //构造器 初始化empLinkedListArray\n    public HashTab(int size){\n        this.size = size;\n        empLinkedListArray = new EmpLinkedList[size];\n        for (int i = 0; i < size; i++) {\n            empLinkedListArray[i] = new EmpLinkedList();\n        }\n    }\n\n    //添加雇员  根据雇员id，得到雇员应该添加到哪条链表\n    public void add(Emp emp){\n        int empLinkedListNo = hashFun(emp.id);\n        empLinkedListArray[empLinkedListNo].add(emp);\n    }\n\n    //遍历链表，遍历hashtab\n    public void list(){\n        for (int i = 0; i < size; i++) {\n            empLinkedListArray[i].list(i+1);\n        }\n    }\n\n    //根据输入的id查找雇员\n    public void findEmpById(int id){\n        int empLinkedListNo = hashFun(id);\n        Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id);\n        if (emp != null){\n            System.out.printf(\"在第%d条链表中找到id = %d的雇员\",(empLinkedListNo+1),id);\n            System.out.println();\n        }else{\n            System.out.println(\"在哈希表中，没有找到该雇员\");\n        }\n    }\n    //编写散列函数 使用取模法\n    public int hashFun(int id){\n        return id % size;\n    }\n}\n\n\nclass Emp{\n    public int id;\n    public String name;\n    public Emp next;\n\n    public Emp(int id,String name) {\n        super();\n        this.id=id;\n        this.name=name;\n    }\n}\n//创建EmpLinkedList ， 表示链表\nclass EmpLinkedList{\n    //头指针，执行第一个Emp，因此我们这个链表的head 是指向第一个Emp\n    private Emp head;//默认为null\n\n    /* 添加雇员到链表\n    说明：  假定，当添加雇员时，id是自增长，即id的分配总是从小到大\n           因此将雇员直接加入到链表最后即可\n     */\n    public void add(Emp emp){\n        //如果添加的是第一个员工\n        if (head == null){\n            head = emp;\n            return;\n        }\n        //如果不是第一个员工，则需要辅助指针定位到最后\n        Emp curEmp = head;\n        while (true){\n            if (curEmp.next == null){//到链表最后\n                break;\n            }\n            curEmp = curEmp.next;//后移\n        }\n        //退出时直接将emp加入链表\n        curEmp.next = emp;\n    }\n\n    //遍历链表\n    public void list(int no){\n        if (head == null){\n            System.out.println(\"第\"+no+\"链表为空\");\n            return;\n        }\n        System.out.print(\"第\"+no+\"链表信息为\");\n        Emp curEmp = head;//辅助指针\n        while (true){\n            System.out.printf(\"=> id=%d name=%s\\t\",curEmp.id,curEmp.name);\n            if (curEmp.next == null){//已经到链表最后\n                break;\n            }\n            curEmp = curEmp.next;//后移，完成遍历\n        }\n        System.out.println();\n    }\n\n    //根据id查找雇员\n    public Emp findEmpById(int id){\n        if (head  == null){\n            System.out.println(\"链表为空\");\n            return null;\n        }\n        Emp curEmp = head;\n        while (true){\n            if (curEmp.id == id){\n                break;\n            }\n            if (curEmp.next == null){//没有找到雇员，退出\n                curEmp=null;\n                break;\n            }\n            curEmp = curEmp.next;\n        }\n        return curEmp;\n    }\n}\n~~~\n\n# 树结构：\n\n## 二叉树：\n\n![image-20200902103839445](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902103839445.png)\n\n#### 数组存储方式：\n\n![image-20200902103953146](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902103953146.png)\n\n#### 链表存储方式：\n\n![image-20200902104057750](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902104057750.png)\n\n#### 二叉排序树：\n\n![image-20200902104219079](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902104219079.png)\n\n#### 树示意图：\n\n![image-20200902104954345](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902104954345.png)\n\n#### 二叉树的概念：\n\n![image-20200902105150085](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902105150085.png)\n\n![image-20200902105206234](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902105206234.png)\n\n## 二叉树遍历说明：\n\n![image-20200902105530182](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200902105530182.png)\n\n\n\n## 思路分析：\n\n~~~tex\n分析二叉树的前序、中序、后序的遍历步骤\n1、创建一颗二叉树\n-----------------------------------\n2.前序遍历：\n2.1先输出当前节点(初始的时候是root节点)\n2.2如果当前节点的左节点不为空，则递归继续前序遍历\n2.3如果当前节点的右节点不为空，则递归继续前序遍历\n-----------------------------------\n3.中序遍历：\n3.1如果当前节点的左节点不为空，则递归继续中序遍历\n3.2输出当前节点\n3.3如果当前节点的右节点不为空，则递归继续中序遍历\n-----------------------------------\n4.后序遍历：\n4.1如果当前节点的左节点不为空，则递归继续后序遍历\n4.2如果当前节点的右节点不为空，则递归继续后序遍历\n4.3输出当前节点\n~~~\n\n## 代码实现：\n\n~~~java\npublic class BinaryTreeDemo {\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n\n        HeroNode root = new HeroNode(1,\"a\");\n        HeroNode node1 = new HeroNode(2,\"b\");\n        HeroNode node2 = new HeroNode(3,\"c\");\n        HeroNode node3 = new HeroNode(4,\"d\");\n        HeroNode node4 = new HeroNode(5,\"e\");\n\n        tree.setRoot(root);\n        root.setLeft(node1);\n        root.setRight(node2);\n        node2.setRight(node3);\n        node2.setLeft(node4);\n\n        System.out.println(\"前序遍历\");\n        tree.preOrder();\n\n        System.out.println(\"中序遍历\");\n        tree.infixOrder();\n\n        System.out.println(\"后序遍历\");\n        tree.postOrder();\n    }\n}\n\n//定义BinaryTree二叉树\nclass BinaryTree{\n    private HeroNode root;\n\n    public void setRoot(HeroNode root) {\n        this.root = root;\n    }\n\n    //前序遍历\n    public void preOrder(){\n        if (this.root != null){\n            this.root.preOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n\n    //中序遍历\n    public void infixOrder(){\n        if (this.root != null){\n            this.root.infixOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n\n    //后序遍历\n    public void postOrder(){\n        if (this.root != null){\n            this.root.postOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n}\n\n\n//先创建HeroNode节点\nclass HeroNode{\n    private int no;\n    private String name;\n    private HeroNode left;\n    private HeroNode right;\n\n    public HeroNode(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public HeroNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(HeroNode left) {\n        this.left = left;\n    }\n\n    public HeroNode getRight() {\n        return right;\n    }\n\n    public void setRight(HeroNode right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n\n    //前序遍历\n    public void preOrder(){\n        //先输出父节点\n        System.out.println(this);\n        //递归向左子树前序遍历\n        if (this.left != null){\n            this.left.preOrder();\n        }\n        //递归向右子树前序遍历\n        if (this.right != null){\n            this.right.preOrder();\n        }\n    }\n\n    //中序遍历\n    public void infixOrder(){\n        //递归向左子树中序遍历\n        if (this.left != null){\n            this.left.infixOrder();\n        }\n        //输出父节点\n        System.out.println(this);\n        //递归向右子树中序遍历\n        if (this.right != null){\n            this.right.infixOrder();\n        }\n    }\n\n    //后序遍历\n    public void postOrder(){\n        //递归向左子树后序遍历\n        if (this.left != null){\n            this.left.postOrder();\n        }\n        //递归向右子树后序遍历\n        if (this.right != null){\n            this.right.postOrder();\n        }\n        //输出父节点\n        System.out.println(this);\n    }\n}\n~~~\n## 二叉树查找:\n\n### 思路分析：\n\n![image-20201009151321836](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201009151321836.png)\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Tree;\n\npublic class BinaryTreeDemo {\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n\n        HeroNode root = new HeroNode(1,\"a\");\n        HeroNode node1 = new HeroNode(2,\"b\");\n        HeroNode node2 = new HeroNode(3,\"c\");\n        HeroNode node3 = new HeroNode(4,\"d\");\n        HeroNode node4 = new HeroNode(5,\"e\");\n\n        tree.setRoot(root);\n\n        root.setLeft(node1);\n        root.setRight(node2);\n\n        node2.setRight(node3);\n        node2.setLeft(node4);\n\n        System.out.println(\"前序遍历\");\n        tree.preOrder();\n\n        System.out.println(\"中序遍历\");\n        tree.infixOrder();\n\n        System.out.println(\"后序遍历\");\n        tree.postOrder();\n\n        System.out.println(\"====================\");\n        System.out.println(\"前序查找\");\n        HeroNode resNode = tree.preOrderSearch(5);\n        if (resNode != null){\n            System.out.printf(\"找到了，信息： no=%d name=%s\",resNode.getNo(),resNode.getName());\n        }else{\n            System.out.printf(\"没有找到编号为%d\",5);\n        }\n\n        System.out.println();\n        System.out.println(\"====================\");\n        System.out.println(\"中序查找\");\n        resNode = tree.infixOrderSearch(5);\n        if (resNode != null){\n            System.out.printf(\"找到了，信息： no=%d name=%s\",resNode.getNo(),resNode.getName());\n        }else{\n            System.out.printf(\"没有找到编号为%d\",5);\n        }\n\n        System.out.println();\n        System.out.println(\"====================\");\n        System.out.println(\"后序查找\");\n        resNode = tree.postOrderSearch(5);\n        if (resNode != null){\n            System.out.printf(\"找到了，信息： no=%d name=%s\",resNode.getNo(),resNode.getName());\n        }else{\n            System.out.printf(\"没有找到编号为%d\",5);\n        }\n    }\n}\n\n//定义BinaryTree二叉树\nclass BinaryTree{\n    private HeroNode root;\n\n    public void setRoot(HeroNode root) {\n        this.root = root;\n    }\n\n    //前序遍历\n    public void preOrder(){\n        if (this.root != null){\n            this.root.preOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n\n    //中序遍历\n    public void infixOrder(){\n        if (this.root != null){\n            this.root.infixOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n\n    //后序遍历\n    public void postOrder(){\n        if (this.root != null){\n            this.root.postOrder();\n        }else{\n            System.out.println(\"当前二叉树为空\");\n        }\n    }\n\n    //前序查找\n    public HeroNode preOrderSearch(int no){\n        if (root != null){\n            return  root.preOrderSearch(no);\n        }else{\n            return null;\n        }\n    }\n\n    //前序查找\n    public HeroNode infixOrderSearch(int no){\n        if (root != null){\n            return  root.infixOrderSearch(no);\n        }else{\n            return null;\n        }\n    }\n\n    //前序查找\n    public HeroNode postOrderSearch(int no){\n        if (root != null){\n            return  root.postOrderSearch(no);\n        }else{\n            return null;\n        }\n    }\n}\n\n\n//先创建HeroNode节点\nclass HeroNode{\n    private int no;\n    private String name;\n    private HeroNode left;\n    private HeroNode right;\n\n    public HeroNode(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public HeroNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(HeroNode left) {\n        this.left = left;\n    }\n\n    public HeroNode getRight() {\n        return right;\n    }\n\n    public void setRight(HeroNode right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n\n    //前序遍历\n    public void preOrder(){\n        //先输出父节点\n        System.out.println(this);\n        //递归向左子树前序遍历\n        if (this.left != null){\n            this.left.preOrder();\n        }\n        //递归向右子树前序遍历\n        if (this.right != null){\n            this.right.preOrder();\n        }\n    }\n\n    //中序遍历\n    public void infixOrder(){\n        //递归向左子树中序遍历\n        if (this.left != null){\n            this.left.infixOrder();\n        }\n        //输出父节点\n        System.out.println(this);\n        //递归向右子树中序遍历\n        if (this.right != null){\n            this.right.infixOrder();\n        }\n    }\n\n    //后序遍历\n    public void postOrder(){\n        //递归向左子树后序遍历\n        if (this.left != null){\n            this.left.postOrder();\n        }\n        //递归向右子树后序遍历\n        if (this.right != null){\n            this.right.postOrder();\n        }\n        //输出父节点\n        System.out.println(this);\n    }\n\n    /**\n     *  前序遍历查找\n     * @param no    需要查找的序号 no\n     * @return      如果找到则返回HeroNode，否则返回null\n     */\n    public HeroNode preOrderSearch(int no){\n        System.out.println(\"前序遍历查找~~~\");\n        //比较当前节点是不是\n        if (this.no == no){\n            return this;\n        }\n        //先判断当前节点的做子节点是否为空，不为空则递归前序查找\n        //如果前序查找 找到节点 则返回\n        HeroNode resNode = null;\n        if (this.left != null){\n            resNode = this.left.preOrderSearch(no);\n        }\n        if (resNode != null){\n            return resNode;\n        }\n        //若左边前序查找完没有找到，先判断当前节点的右子节点是否为空 不为空则递归前序查找\n        //找到则返回 没有则返回null\n        if (this.right != null){\n            resNode = this.right.preOrderSearch(no);\n        }\n        return resNode;\n    }\n\n    /**\n     * 中序查找\n     * @param no    需要查找的序号 no\n     * @return      如果找到则返回HeroNode，否则返回null\n     */\n    public HeroNode infixOrderSearch(int no){\n        HeroNode resNode = null;\n        //向左遍历查找\n        if (this.left != null){\n            resNode = this.left.infixOrderSearch(no);\n        }\n        if (resNode != null){\n            return resNode;\n        }\n        System.out.println(\"中序遍历查找~~~\");\n        //当前节点\n        if (this.no == no){\n            return this;\n        }\n        //向右遍历查找\n        if (this.right != null){\n            resNode = this.right.infixOrderSearch(no);\n        }\n        return resNode;\n    }\n\n    /**\n     * 后序查找\n     * @param no    需要查找的序号 no\n     * @return      如果找到则返回HeroNode，否则返回null\n     */\n    public HeroNode postOrderSearch(int no){\n        HeroNode resNode = null;\n        //向左遍历查找\n        if (this.left != null){\n            resNode = this.left.postOrderSearch(no);\n        }\n        if (resNode != null){\n            return resNode;\n        }\n        //向右遍历查找\n        if (this.right != null){\n            resNode = this.right.postOrderSearch(no);\n        }\n        if (resNode != null){\n            return resNode;\n        }\n        System.out.println(\"后序遍历查找~~~\");\n        //左右子树都没，查找当前节点\n        if (this.no == no){\n            return this;\n        }\n        return resNode;\n    }\n}\n~~~\n\n## 二叉树删除节点：\n\n### 思路分析：\n\n![image-20201009162310883](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201009162310883.png)\n\n### 代码实现：\n\n~~~java\npackage com.cyq.Tree;\n\npublic class BinaryTreeDemo {\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n\n        HeroNode root = new HeroNode(1, \"a\");\n        HeroNode node1 = new HeroNode(2, \"b\");\n        HeroNode node2 = new HeroNode(3, \"c\");\n        HeroNode node3 = new HeroNode(4, \"d\");\n        HeroNode node4 = new HeroNode(5, \"e\");\n\n        tree.setRoot(root);\n\n        root.setLeft(node1);\n        root.setRight(node2);\n\n        node2.setRight(node3);\n        node2.setLeft(node4);\n\n        \n\n        System.out.println(\"=======================\");\n        System.out.println(\"删除前，前序遍历\");\n        tree.preOrder();\n//        tree.delNode(5);\n        tree.delNode(3);\n        System.out.println(\"删除后，前序遍历\");\n        tree.preOrder();\n    }\n}\n\n//定义BinaryTree二叉树\nclass BinaryTree {\n    private HeroNode root;\n\n    public void setRoot(HeroNode root) {\n        this.root = root;\n    }\n\n    \n\n    //删除节点\n    public void delNode(int no){\n        if (root != null){\n            //如果root只有一个节点，立即判断root是否就是需要删除的节点\n            if(root.getNo() == no){\n                root =null;\n            }else{\n                //递归删除\n                root.delNode(no);\n            }\n        }else{\n            System.out.println(\"空树不能删除\");\n        }\n    }\n}\n\n\n//先创建HeroNode节点\nclass HeroNode {\n    private int no;\n    private String name;\n    private HeroNode left;\n    private HeroNode right;\n\n    public HeroNode(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public HeroNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(HeroNode left) {\n        this.left = left;\n    }\n\n    public HeroNode getRight() {\n        return right;\n    }\n\n    public void setRight(HeroNode right) {\n        this.right = right;\n    }\n\n\n    /*\n      递归删除节点\n        1、如果删除的节点是叶子节点，则删除该节点\n        2、如果删除的节点是飞叶子节点，则删除该子树\n    */\n    public void delNode(int no) {\n        //如果当前节点的左子节点不为空，并且左子节点 就是要删除的节点 将this.left = null;并且返回(结束递归)\n        if (this.left != null && this.left.no == no) {\n            this.left = null;\n            return;\n        }\n        //如果当前节点的右子节点不为空，并且右子节点 就是要删除的节点 将this.right = null;并且返回(结束递归)\n        if (this.right != null && this.right.no == no) {\n            this.right = null;\n            return;\n        }\n        //如果前面都没找到需要删除的节点 就需要向左子树进行递归删除\n        if (this.left != null) {\n            this.left.delNode(no);\n        }\n        //如果前面都没找到需要删除的节点 就需要向左子树进行递归删除\n        if (this.right != null) {\n            this.right.delNode(no);\n        }\n    }\n}\n~~~\n\n## 顺序存储二叉树：\n\n![image-20201009165558518](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201009165558518.png)\n\n### 顺序二叉树存储特点：（应用实例堆排序）\n\n1. 顺序二叉树通常只考虑完全二叉树\n2. 第n个元素的左子节点为2 * n + 1\n3. 第n个元素的右子节点为2 * n + 2\n4. 第n个元素的父子节点为 ( n - 1 ) / 2\n5. n:表示二叉树中的第几个元素(按0开始编号)\n\n~~~java\npackage com.cyq.Tree;\n\npublic class ArrayBinaryTreeDemo {\n    public static void main(String[] args) {\n        int arr [] = {1,2,3,4,5,6,7};\n        ArrayBinaryTree tree = new ArrayBinaryTree(arr);\n\n        System.out.println(\"前序遍历\");\n        tree.preOrder();\n\n        System.out.println();\n        System.out.println(\"中序遍历\");\n        tree.infixOrder();\n\n        System.out.println();\n        System.out.println(\"后序遍历\");\n        tree.postOrder();\n    }\n}\n\nclass ArrayBinaryTree{\n    private int [] arr;//存储数据节点的数组\n\n    public ArrayBinaryTree(int[] arr) {\n        this.arr = arr;\n    }\n\n    public void preOrder(){\n        this.preOrder(0);\n    }\n\n    public void infixOrder(){\n        this.infixOrder(0);\n    }\n\n    public void postOrder(){\n        this.postOrder(0);\n    }\n\n    /**\n     *  顺序存储二叉树的前序遍历\n     * @param index 数组的下标\n     */\n    public void preOrder(int index){\n        //如果数组为空，或者arr.length = 0\n        if(arr == null || arr.length == 0){\n            System.out.println(\"数组为空，不能进行遍历\");\n        }\n        //输出当前这个节点\n        System.out.print(arr[index]+\" \");\n        //向左递归遍历\n        if ((index * 2 + 1) < arr.length){\n            preOrder(index * 2 + 1);\n        }\n        //向右递归遍历\n        if ((index * 2 + 2) <arr.length){\n            preOrder(index * 2 + 2);\n        }\n    }\n\n    /**\n     *  顺序存储二叉树的中序遍历\n     * @param index 数组的下标\n     */\n    public void infixOrder(int index){\n        //如果数组为空，或者arr.length = 0\n        if(arr == null || arr.length == 0){\n            System.out.println(\"数组为空，不能进行遍历\");\n        }\n        //向左递归遍历\n        if ((index * 2 + 1) < arr.length){\n            preOrder(index * 2 + 1);\n        }\n        //输出当前这个节点\n        System.out.print(arr[index]+\" \");\n        //向右递归遍历\n        if ((index * 2 + 2) <arr.length){\n            preOrder(index * 2 + 2);\n        }\n    }\n\n    /**\n     *  顺序存储二叉树的后序遍历\n     * @param index 数组的下标\n     */\n    public void postOrder(int index){\n        //如果数组为空，或者arr.length = 0\n        if(arr == null || arr.length == 0){\n            System.out.println(\"数组为空，不能进行遍历\");\n        }\n        //向左递归遍历\n        if ((index * 2 + 1) < arr.length){\n            preOrder(index * 2 + 1);\n        }\n        //向右递归遍历\n        if ((index * 2 + 2) <arr.length){\n            preOrder(index * 2 + 2);\n        }\n        //输出当前这个节点\n        System.out.print(arr[index]+\" \");\n    }\n}\n~~~\n\n\n\n', '2020-10-01 16:44:28', 0);
INSERT INTO `tb_blog` VALUES (7, 1, 'JavaWeb学习文档', '对于学习javaweb笔记整理', '[PDF下载](http://cxycyq.gitee.io/pigblog/img/pdf/Web.pdf)\n\n# 创建Tomcat服务器的web动态工程：\n\n![image-20200904154715090](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904154715090.png)\n\n# 目录：\n\n![image-20200904154715090](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904154715090.png)\n\n# Tomcat整体架构：\n\n![image-20200904163052914](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904163052914.png)\n\n# Servlet容器工作流程\n\n![image-20200904163408016](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904163408016.png)\n\n# Tomcat整体架构：\n\n![image-20200904163612653](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904163612653.png)\n\n# Coyote连接器：\n\n![image-20200904164140307](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904164140307.png)\n\n# Coyote组件：\n\n![image-20200904164239836](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904164239836.png)\n\n# Tomcat的模块：\n\n![image-20200904164356983](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904164356983.png)\n\n# Servlet技术是什么：\n\n![image-20200904170146439](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904170146439.png)\n\n# Servlet需要在web.xml中配置：\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!-- servlet标签给Tomcat配置Servlet程序   -->\n    <servlet>\n<!--        servlet程序起一个别名（一般是类名）-->\n        <servlet-name>HelloServlet</servlet-name>\n<!--        servlet程序的全类名-->\n        <servlet-class>com.study.HelloServlet</servlet-class>\n    </servlet>\n\n<!--    给servlet程序配置访问地址-->\n    <servlet-mapping>\n<!--        告诉服务器，当前配置的地址给哪个Servlet程序使用-->\n        <servlet-name>HelloServlet</servlet-name>\n<!--        配置访问地址\n            /  斜杆在服务器解析时，表示地址为：http://ip:port/工程路径\n            /hello             表示地址为：http://ip:port/工程路径/hello\n-->\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n</web-app>\n~~~\n\n# Servlet的生命周期：\n\n~~~tex\n1、执行Servlet构造器方法\n2、执行init初始化方法\n	第一第二步在第一次访问的时候创建servlet程序会调用\n3、执行service方法\n	每次访问都会调用\n4、执行destroy销毁方法\n	在web工程停止的时候调用\n~~~\n\n\n\n# Servlet获取表单请求方法：\n\n## ~！需要现在web.xml中编写路径\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!-- servlet标签给Tomcat配置Servlet程序   -->\n    <servlet>\n<!--        servlet程序起一个别名（一般是类名）-->\n        <servlet-name>HelloServlet</servlet-name>\n<!--        servlet程序的全类名-->\n        <servlet-class>com.study.HelloServlet</servlet-class>\n    </servlet>\n\n<!--    给servlet程序配置访问地址-->\n    <servlet-mapping>\n<!--        告诉服务器，当前配置的地址给哪个Servlet程序使用-->\n        <servlet-name>HelloServlet</servlet-name>\n<!--        配置访问地址\n            /  斜杆在服务器解析时，表示地址为：http://ip:port/工程路径\n            /hello             表示地址为：http://ip:port/工程路径/hello\n-->\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n~~~\n\n\n\n## 1、通过实现Servlet接口来实现Servlet程序\n\n~~~html\n//在WEB_INF下编写html文件\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>a</title>\n</head>\n<body>\n<form action=\"http://localhost:8080/web_tomcat_war_exploded/hello\" method=\"post\">\n    <input type=\"submit\">\n</form>\n</body>\n</html>\n~~~\n\n~~~java\npackage com.study;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class HelloServlet implements Servlet {\n\n    public HelloServlet() {\n        System.out.println(\"1 构造器方法\");\n    }\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        System.out.println(\"2 初始化方法\");\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    /**\n     * service方法是专门处理用户请求和响应的\n     * @param servletRequest\n     * @param servletResponse\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"3 === Servlet 被访问了\");\n\n        //ServletRequest下的子类，拥有getMethod()方法\n        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n        //获取请求的方式\n        String method = httpServletRequest.getMethod();\n\n        if(\"POST\".equals(method)){\n            dopost();\n        }else if(\"GET\".equals(method)){\n            doget();\n        }\n    }\n    \n    public void doget(){\n        System.out.println(\"GET请求\");\n    }\n    \n    public void dopost(){\n        System.out.println(\"POST请求\");\n    }\n    \n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"4 destroy方法\");\n    }\n}\n\n~~~\n\n\n\n## 2、继承HttpServlet类的方式去实现Servlet程序\n\n1. 编写一个类去继承HttpServlet类\n2. 根据业务需求重写doGet()或者doPost()方法\n3. 到web.xml中配置Servlet程序的访问地址\n\n~~~java\n//编写后需要在web.xml中配置路径\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class HelloServlet1 extends HttpServlet {\n\n    /**\n     * doGet() 在get请求是调用\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"HelloServlet1 的doGet方法\");\n    }\n\n    /**\n     * doPost() 在post请求是调用\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"HelloServlet1 的doPost方法\");\n    }\n}\n\n~~~\n\n## 3、使用IDEA创建Servlet程序\n\n\n\n~~~tex\n在page中右键 new->Creat New Servlet\n进入后取消使用Java EE 6 注释\n创建后需要在web.xml中编写\n<servlet-mapping>\n        <servlet-name></servlet-name>\n        <url-pattern></url-pattern>\n    </servlet-mapping>\n~~~\n\n\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904203334765.png\" alt=\"image-20200904203334765\" style=\"zoom:80%;\" />\n\n![image-20200904203429631](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904203429631.png)\n\n# Servlet类的继承体系：\n\n![image-20200904205211566](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200904205211566.png)\n\n# ServletConfig类的三大作用：\n\n1. 可以获取Servlet程序的别名servlet-name 的值\n2. 获取初始化参数init-param\n3. 获取ServletContext 对象\n\n~~~java\n//public class HelloServlet implements Servlet中的init方法\n\n@Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        System.out.println(\"2 初始化方法\");\n\n//        1. 可以获取Servlet程序的别名servlet-name 的值\n        System.out.println(\"HelloServlet的别名是：\"+servletConfig.getServletName());\n//        2. 获取初始化参数init-param\n        System.out.println(\"初始化参数username的值是：\"+servletConfig.getInitParameter(\"username\"));\n        System.out.println(\"初始化参数url的值是：\"+servletConfig.getInitParameter(\"url\"));\n//        3. 获取ServletContext 对象\n        System.out.println(servletConfig.getServletContext());\n    }\n\n~~~\n\n~~~xml\n//获取初始化参数init-param\n//需要在web.xml中配置\n<!--        init-param是初始化参数-->\n        <init-param>\n<!--            参数名-->\n            <param-name>username</param-name>\n<!--            参数值-->\n            <param-value>root</param-value>\n        </init-param>\n\n~~~\n\n1. Servlet程序和ServletConfig对象都是有Tomcat负责创建，用户负责使用。\n2. Servlet程序默认第一次访问的时候创建，ServletConfig是每个Servlet程序创建时，就创建一个对应的ServletConfig对象\n\n# ServletContext类：\n\n~~~te\n1、ServletContext是一个接口，它表示Servlet上下文对象\n2、一个web工程，只有一个ServletContext对象实例\n3、ServletContext对象是一个域对象\n4、ServletContext是在web工程部署启动的时候创建。在web工程停止是销毁\n 域对象：\n 域对象，是可以像Map一样存取数据的对象，叫域对象。这里的域指的是存取数据的操作范围(整个web工程)\n \n    		存数据					取数据					删除数据\n Map		put()				    get() 				   remove()\n 域对象	  putAttribute()		  getAttribute() 		  removeAttribute()\n~~~\n\n## ServletContext类的四个作用：\n\n1. 获取web.xml中的配置的上下文参数 context-param\n2. 获取当前的工程路径，格式:/工程路径\n3. 获取工程部署后在服务器硬盘上的绝对路径\n4. 像Map一样存取数据\n\n# HTTP协议：\n\n## 概念：\n\n**客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫http协议。HTTP协议中的数据又叫报文**\n\n## 请求的HTTP协议格式：\n\n1. **客户端给服务器发送数据叫请求。**\n2. **服务器给客户端回传数据叫响应。**\n3. **请求又分为GET请求和POST请求两种**\n\n### GET请求：\n\n~~~tex\n1、请求行\n	(1)请求的方式						GET\n	(2)请求的资源路径[+?+请求参数]\n	(3)请求的协议版本号					  Http/1.1\n2、请求头\n	key：value  组成 不同的键值对，表示不同的含义。\n~~~\n\n![image-20200905162218268](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200905162218268.png)\n\n### POST请求：\n\n~~~te\n1、请求行\n	(1)请求的方式						POST\n	(2)请求的资源路径[+?+请求参数]\n	(3)请求的协议版本号					  Http/1.1\n2、请求头\n	key：value  不同的键值对，表示不同的含义。\n空行\n3、请求体  ===> 发送给服务器的数据\n~~~\n\n![image-20200905223227307](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200905223227307.png)\n\n### GET和POST请求区分：\n\n~~~tex\nGET请求：\n    1、from标签 method=get\n    2、a标签\n    3、link标签引入css\n    4、Script标签引入js文件\n    5、img标签引入图片\n    6、iframe引入html页面\n    7、在浏览器地址栏输入地址后回车\n    \nPOST请求：\n	1、from标签 method=get\n~~~\n\n## 响应的HTTP协议格式：\n\n1、响应行\n\n​	1、响应的协议和版本号\n\n​	2、响应状态码\n\n​	3、响应状态描述符\n\n2、响应头\n\n​	1、key：value   不同的响应头，有其不同含义\n\n空行\n\n3、响应体  ===>>>  回传给客户端的数据\n\n​	![image-20200905224421718](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200905224421718.png)\n\n# MIME类型：\n\n**MIME是HTTP协议中的数据类型**\n\n![image-20200905224618442](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200905224618442.png)H\n\n# HttpServletRequest类：\n\n## 作用：\n\n**每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析封装到Request对象中。然后传递到service方法(doGet和doPost)中给我们使用。我们通过HttpServletRequest对象，获取到所有请求的信息**\n\n# HttpServletRequest类的常用方法：\n\n~~~java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class RequestAPIServlet  extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1、getRequestURI()         获取请求资源路径\n        System.out.println(\"URI =>> \"+req.getRequestURI());\n        //2、getRequestURL()         获取请求资源的统一资源定位符(绝对路径)\n        System.out.println(\"URL =>> \"+req.getRequestURL());\n        /**\n         * 在IDEA中，使用localhost访问时，得到的客户端IP地址是 ==>>  0:0:0:0:0:0:0:1 = 127.0.0.1\n         * 在IDEA中，使用127.0.0.1访问时，得到的客户端IP地址是 ==>>  127.0.0.1\n         * 在IDEA中，使用真实IP访问时，得到的客户端IP地址是 ==>>  真实的客户端IP地址\n         */\n        //3、getRemoteHost()         获取客户端的IP地址\n        System.out.println(\"客户端IP地址：\"+req.getRemoteHost());\n        //4、getHeader(String s)     获取请求头\n        System.out.println(\"请求头User-Agent ==>>\"+req.getHeader(\"User-Agent\"));\n        //5、getMethod()             获取请求的方式GET或POST\n        System.out.println(\"请求的方式 ==>>\"+req.getMethod());\n    }\n}\n\n~~~\n\n# Servlet获取请求参数值：\n\n编写form.xml在web.xml中配置路径  在ParameterServlet.java中编写doGet()或doPost()方法\n\n~~~xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <form action=\"http://localhost:8080/01_servlet/request1\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\"> <br>\n        密码：<input type=\"password\" name=\"password\"><br>\n        兴趣爱好：<input type=\"checkbox\" name=\"hobby\" value=\"cpp\">C++\n                <input type=\"checkbox\" name=\"hobby\" value=\"java\">Java\n                <input type=\"checkbox\" name=\"hobby\" value=\"js\">JavaScript <br>\n        <input type=\"submit\">\n\n    </form>\n</body>\n</html>\n~~~\n\n~~~java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\npublic class ParameterServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        System.out.println(\"-------doGet--------\");\n        //获取请求参数\n        /*\n        * getParameterValues(String s) 获取多个参数值的是时候使用\n        * */\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String[] hobby = req.getParameterValues(\"hobby\");\n\n        System.out.println(\"用户名：\"+username);\n        System.out.println(\"密码：\"+password);\n        System.out.println(\"兴趣爱好：\"+ Arrays.asList(hobby));\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"-------doPost--------\");\n\n        //设置请求体的字符集为UTF-8，从而解决POST请求的中文乱码问题。eg：?????±???é?????é??\n        //必须在h获取请求参数之前调用才有效\n        req.setCharacterEncoding(\"UTF-8\");\n\n\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String[] hobby = req.getParameterValues(\"hobby\");\n\n        System.out.println(\"用户名：\"+username);\n        System.out.println(\"密码：\"+password);\n        System.out.println(\"兴趣爱好：\"+ Arrays.asList(hobby));\n    }\n}\n\n~~~\n\n# 请求转发：\n\n![image-20200906104813991](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200906104813991.png)\n\n### Servlet1程序：\n\n~~~java\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class Servlet1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求的参数(办事的材料) 查看\n        String username = req.getParameter(\"username\");\n        System.out.println(\"在Servlet1(柜台1)中查看参数(材料)：\"+username);\n\n        //给材料盖章，并传递到Servlet2（柜台2）中查看\n        req.setAttribute(\"key1\",\"柜台1的章\");\n\n        //问路 Servlet2（柜台2）怎么走   !!!请求转发必须以/打头\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/servlet2\");//http://localhost:8080/01_servlet/servlet1?username=asd\n//        RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/WEB-INF/form.html\");//http://localhost:8080/01_servlet/servlet1\n\n        //走向Servlet2（柜台2）\n        requestDispatcher.forward(req, resp);\n    }\n}\n\n~~~\n\n### Servlet2程序：\n\n~~~java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class Servlet2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求的参数(办事的材料) 查看\n        String username = req.getParameter(\"username\");\n        System.out.println(\"在Servlet2(柜台2)中查看参数(材料)：\"+username);\n\n        //查看柜台1是否有盖章\n        Object key1 = req.getAttribute(\"key1\");\n        System.out.println(\"柜台1是否有盖章\"+key1);\n\n        //处理自己的业务\n        System.out.println(\"Servlet2 处理自己的业务\");\n    }\n}\n\n~~~\n\n**服务器放回结果：**\n\n~~~tex\n在Servlet1(柜台1)中查看参数(材料)：asd\n在Servlet2(柜台2)中查看参数(材料)：asd\n柜台1是否有盖章柜台1的章\nServlet2 处理自己的业务\n~~~\n\n## 请求转发的特点：\n\n~~~tex\n1、浏览器地址没有变化\n2、他们是一次请求\n3、他们共享Request域中的数据\n4、可以转发到WEB-INF目录下\n5、不可以访问工程以外的资源\n~~~\n\n# Base标签：\n\n![image-20200909165624413](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200909165624413.png)\n\n**c.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>c</title>\n    <!--  base标签设置页面相对路径工作参照的地址\n            href 属性就是参数的地址值-->\n    <base href=\"http://localhost:8080/01_servlet/a/b/c.html\">\n</head>\n<body>\n    这是a下的b下的c.html页面 <br>\n    <a href=\"../../index.html\">跳回首页</a>\n\n\n</body>\n</html>\n```\n\n**index.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>首页</title>\n</head>\n<body>\n    这是web下的index.html <br>\n    <a href=\"a/b/c.html\">a/b/c.html</a> <br>\n    <a href=\"http://localhost:8080/01_servlet/forwordC\">请求转发：a/b/c.html</a>\n</body>\n</html>\n```\n\n**ForwordC.java**\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class ForwordC extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"经过了ForwordC程序\");\n        req.getRequestDispatcher(\"/a/b/c.html\").forward(req,resp);\n    }\n}\n```\n\n\n\n# HttpServletResponse类：\n\n## 作用：\n\n**每次只要有请求进入Tomcat服务器都会创建一个HttpServletResponse对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来设置**\n\n# 两个输出流：\n\n~~~tex\n字节流：   getOutputStream();  		常用于下载(传递二进制数据)\n字符流     getWriter();			常用于回传字符串(常用)\n两个流只能同时使用一个。\n使用了字节流，就不能再使用字符流，反之亦然，否则会报错\n~~~\n\n\n\n\n\n# 书城项目：\n\n# JavaEE三层架构：\n\n![image-20200906110212003](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200906110212003.png)\n\n![image-20200906110628990](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200906110628990.png)\n\n![image-20200911130923534](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200911130923534.png)\n\n## 1、创建数据库表：\n\n![image-20200911130749818](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200911130749818.png)\n\n## 2、编写数据库表对应的javaBean对象：\n\n~~~java\npackage com.study.pojo;\n\nimport java.security.PrivateKey;\n\npublic class User {\n\n    private Integer id;\n    private String username;\n    private String password;\n    private String email;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username=\'\" + username + \'\\\'\' +\n                \", password=\'\" + password + \'\\\'\' +\n                \", email=\'\" + email + \'\\\'\' +\n                \'}\';\n    }\n\n    public User() {\n    }\n\n    public User(Integer id, String username, String password, String email) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.email = email;\n    }\n}\n\n~~~\n\n## 3、编写工具类jdbcUtils：\n\n~~~java\npackage com.study.utils;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class JdbcUtils {\n\n    private static DruidDataSource dataSource;\n\n    static {\n        try {\n            Properties properties = new Properties();\n            // 读取 jdbc.properties属性配置文件\n            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n            // 从流中加载数据\n            properties.load(inputStream);\n            // 创建 数据库连接 池\n            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n    }\n    /**\n     * 获取数据库连接池中的连接\n     *\n     * @return 如果返回null, 说明获取连接失败，  有值就是获取连接成功\n     */\n    public static Connection getConnection() {\n\n        Connection conn = null;\n\n        try {\n            conn = dataSource.getConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return conn;\n    }\n\n    /**\n     * 关闭连接，放回数据库连接池\n     *\n     * @param conn\n     */\n    public static void close(Connection conn) {\n        if (conn != null) {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n~~~\n\n## 4、编写baseDao：\n\n~~~java\npackage com.study.dao.impl;\n\nimport com.study.utils.JdbcUtils;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic abstract class BaseDao {\n\n    //使用DbUtils操作数据库\n    private QueryRunner queryRunner = new QueryRunner();\n\n    /**\n     * update() 方法执行 Insert/Update/Delete语句\n     *\n     * @return 如果放回-1，说明执行失败。放回其他表示影响的行数\n     */\n    public int update(String sql, Object... args) {\n        Connection con = JdbcUtils.	getConnection();\n        try {\n            return queryRunner.update(con, sql, args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(con);\n        }\n        return -1;\n    }\n\n    /**\n     * 查询返回一个javaBean的sql语句\n     *\n     * @param type 返回的对象类型\n     * @param sql  执行的sql语句\n     * @param args sql对应的参数值\n     * @param <T>  返回的类型的泛型\n     * @return\n     */\n    public <T> T queryForOne(Class<T> type, String sql, Object... args) {\n        Connection con = JdbcUtils.getConnection();\n        try {\n            return queryRunner.query(con, sql, new BeanHandler<T>(type), args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(con);\n        }\n        return null;\n    }\n\n    /**\n     * 查询返回多个javaBean的sql语句\n     *\n     * @param type 返回的对象类型\n     * @param sql  执行的sql语句\n     * @param args sql对应的参数值\n     * @param <T>  返回的类型的泛型\n     * @return\n     */\n    public <T> List<T> queryForList(Class<T> type, String sql, Object... args) {\n        Connection con = JdbcUtils.getConnection();\n        try {\n            return queryRunner.query(con, sql, new BeanListHandler<>(type), args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(con);\n        }\n        return null;\n    }\n\n    /**\n     * 执行返回一行一列的sql语句\n     *\n     * @param sql  执行的sql语句\n     * @param agrs sql的对应参数值\n     * @return\n     */\n    public Object queryForSingleValue(String sql, Object... agrs) {\n        Connection con = JdbcUtils.getConnection();\n        try {\n            return queryRunner.query(con, sql, new ScalarHandler(), agrs);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(con);\n        }\n        return null\n    }\n}\n~~~\n\n## 5、编写UserDao和测试：\n\n**UserDao接口**\n\n~~~java\npackage com.study.dao;\n\nimport com.study.pojo.User;\n\npublic interface UserDao {\n\n\n    /**\n     * 根据用户名查询用户信息\n     *\n     * @param username 用户名\n     * @return 如果返回null，说明没有这个用户。反之亦然\n     */\n    public User queryUserbyUsername(String username);\n\n\n    /**\n     * 根据用户名和密码查询用户信息\n     *\n     * @param username\n     * @param password\n     * @return\n     */\n    public User queryUserbyUsernameAndPassword(String username, String password);\n\n\n    /**\n     * 保存用户信息\n     *\n     * @param user\n     * @return\n     */\n    public int saveUser(User user);\n}\n\n~~~\n\n​	**UserDaoImpl实现类**\n\n~~~java\npackage com.study.dao.impl;\n\nimport com.study.dao.UserDao;\nimport com.study.pojo.User;\n\npublic class UserDaoImpl extends BaseDao implements UserDao {\n    @Override\n    public User queryUserbyUsername(String username) {\n        String sql = \"select id,username,password,email from t_user where username=? \";\n        return queryForOne(User.class, sql, username);\n    }\n\n    @Override\n    public User queryUserbyUsernameAndPassword(String username, String password) {\n        String sql = \"select id,username,password,email from t_user where username=? and password=?\";\n        return queryForOne(User.class, sql, username, password);\n    }\n\n    @Override\n    public int saveUser(User user) {\n        String sql = \"insert into t_user(username,password,email) value(?,?,?)\";\n        return update(sql, user.getUsername(), user.getPassword(), user.getEmail());\n    }\n}\n\n~~~\n\n**UserDaoTest测试类**\n\n~~~java\npackage com.study.test;\n\nimport com.study.dao.UserDao;\nimport com.study.dao.impl.UserDaoImpl;\nimport com.study.pojo.User;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class UserDaoTest {\n\n    @Test\n    public void queryUserbyUsername() {\n        UserDao userDao = new UserDaoImpl();\n        if (userDao.queryUserbyUsername(\"admin\") == null) {\n            System.out.println(\"用户名可用\");\n        } else {\n            System.out.println(\"用户名也存在\");\n        }\n    }\n\n    @Test\n    public void queryUserbyUsernameAndPassword() {\n        UserDao userDao = new UserDaoImpl();\n        if (userDao.queryUserbyUsernameAndPassword(\"admin\", \"admin\") == null) {\n            System.out.println(\"用户名或密码错误\");\n        } else {\n            System.out.println(\"查询成功\");\n        }\n    }\n\n    @Test\n    public void sanveUser() {\n        UserDao userDao = new UserDaoImpl();\n        System.out.println(userDao.saveUser(new User(null, \"123\", \"123\", \"123@qq.com\")));\n    }\n}\n~~~\n\n## 6、编写UserService和测试：\n\n**UserService接口**\n\n~~~java\npackage com.study.service;\n\nimport com.study.pojo.User;\n\n//Service 业务层\npublic interface UserService {\n\n    /**\n     * 注册用户\n     *\n     * @param user\n     */\n    public void registUser(User user);\n\n    /**\n     * 登录\n     *\n     * @param user\n     * @return 如果返回null，说明登录失败，有值说明登录成功\n     */\n    public User login(User user);\n\n    /**\n     * 检查用户是否可用\n     *\n     * @param username\n     * @return 返回true表示用户名已存在，返回false表示用户名可用\n     */\n    public boolean existsUsername(String username);\n}\n\n~~~\n\n**UserServiceImpl实现类**\n\n~~~java\npackage com.study.service.impl;\n\nimport com.study.dao.UserDao;\nimport com.study.dao.impl.UserDaoImpl;\nimport com.study.pojo.User;\nimport com.study.service.UserService;\n\npublic class UserServiceImpl implements UserService {\n	\n    private UserDao userDao = new UserDaoImpl();\n\n\n    @Override\n    public void registUser(User user) {\n        userDao.saveUser(user);\n    }\n\n    @Override\n    public User login(User user) {\n        return userDao.queryUserbyUsernameAndPassword(user.getUsername(),user.getPassword());\n    }\n	\n    @Override\n    public boolean existsUsername(String username) {\n        if(userDao.queryUserbyUsername(username) == null){//等于null说明没有查到，用户名可用\n            return false;	\n        }\n        return true;\n    }\n}\n\n~~~\n\n**UserServiceTest测试类**\n\n~~~java\npackage com.study.test;\n\nimport com.study.pojo.User;\nimport com.study.service.UserService;\nimport com.study.service.impl.UserServiceImpl;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class UserServiceTest {\n\n    UserService userService = new UserServiceImpl();\n\n    @Test\n    public void registUser() {\n        userService.registUser(new User(null, \"test01\", \"test01\", \"test01@qq.com\"));\n        userService.registUser(new User(null, \"test02\", \"test02\", \"test02@qq.com\"));\n        userService.registUser(new User(null, \"test03\", \"test03\", \"test03@qq.com\"));\n    }\n\n    @Test\n    public void login() {\n        if (userService.login(new User(null, \"test01\", \"test01\", null)) == null) {\n            System.out.println(\"登录失败，用户名或错误\");\n        } else {\n            System.out.println(\"登录成功，登录用户为：\");\n            System.out.println(userService.login(new User(null, \"test01\", \"test01\", null)));\n        }\n    }\n\n    @Test\n    public void existsUsername() {\n        if (userService.existsUsername(\"admin\")) {\n            System.out.println(\"用户名已存在!!!\");\n        } else {\n            System.out.println(\"用户名可用\");\n        }\n    }\n}\n~~~\n\n## 7、实现用户注册功能：\n\n~~~java\npackage com.study.web;\n\nimport com.study.dao.impl.UserDaoImpl;\nimport com.study.pojo.User;\nimport com.study.service.UserService;\nimport com.study.service.impl.UserServiceImpl;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * RegistServlet程序\n * 1、获取请求参数\n * 2、检查验证码是否正确\n *      2.1、正确\n *          3、检查 用户名是否可用\n *          3.1、可用 调用Service保存到数据库 跳转到注册成功的页面\n *          \n *          3.2、不可用 跳回注册页面\n * 2.2、不正确 跳回注册页面\n */\npublic class RegistServlet extends HttpServlet {\n\n    UserService userService = new UserServiceImpl();\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n//  1、获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String email = req.getParameter(\"email\");\n        String code = req.getParameter(\"code\");\n\n//  2、检查验证码是否正确\n        if (\"abcde\".equalsIgnoreCase(code)) {\n//          3、检查 用户名是否可用\n            if (userService.existsUsername(username)) {\n//          3.2、不可用 跳回注册页面\n                System.out.println(\"用户名【\" + username + \"】已存在\");\n                req.getRequestDispatcher(\"/pages/user/regist.html\").forward(req, resp);\n            }\n//          3.1、可用  调用Service保存到数据库   跳转到注册成功的页面\n            else {\n                userService.registUser(new User(null, username, password, email));\n                req.getRequestDispatcher(\"/pages/user/regist_success.html\").forward(req, resp);\n            }\n\n\n        } else {\n//  2.2、不正确 跳回注册页面\n            System.out.println(\"验证码【\" + code + \"】错误\");\n            req.getRequestDispatcher(\"/pages/user/regist.html\").forward(req, resp);\n        }\n\n\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    }\n}\n\n~~~\n\n### 在web.xml中配置路径\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <servlet>\n        <servlet-name>RegistServlet</servlet-name>\n        <servlet-class>com.study.web.RegistServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>RegistServlet</servlet-name>\n        <url-pattern>/registServlet</url-pattern>\n    </servlet-mapping>\n\n    <servlet>\n        <servlet-name>LoginServlet</servlet-name>\n        <servlet-class>com.study.web.LoginServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>LoginServlet</servlet-name>\n        <url-pattern>/loginServlet</url-pattern>\n    </servlet-mapping>\n</web-app>\n~~~\n\n### 在regist.html中添加base标签并修改引入文件的路径：\n\n~~~html\n    <!--写base标签，永远固定相对路径跳转的结果-->\n    <base href=\"http://localhost:8080/book/\">\n~~~\n\n### 在regist.html的form表单中修改action和method：\n\n~~~html\n<form action=\"registServlet\" method=\"post\"></form>\n~~~\n\n# 8、实现用户登录功能：\n\n~~~java\npackage com.study.web;\n\nimport com.study.pojo.User;\nimport com.study.service.UserService;\nimport com.study.service.impl.UserServiceImpl;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebServlet(name = \"LoginServlet\")\npublic class LoginServlet extends HttpServlet {\n\n    UserService userService = new UserServiceImpl();\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        //1、获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n\n        //2、调用userService.login()处理业务\n        User loginUser = userService.login(new User(null, username, password, null));\n        //如果返回值为null，说明登陆失败，\n        if (loginUser == null) {\n            System.out.println(\"用户名或密码错误\");\n            req.getRequestDispatcher(\"/pages/user/login.html\").forward(req, resp);\n        } else {\n            req.getRequestDispatcher(\"/pages/user/login_success.html\").forward(req, resp);\n        }\n    }\n}\n\n~~~\n\n### 在web.xml中配置路径\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <servlet>\n        <servlet-name>RegistServlet</servlet-name>\n        <servlet-class>com.study.web.RegistServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>RegistServlet</servlet-name>\n        <url-pattern>/registServlet</url-pattern>\n    </servlet-mapping>\n\n    <servlet>\n        <servlet-name>LoginServlet</servlet-name>\n        <servlet-class>com.study.web.LoginServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>LoginServlet</servlet-name>\n        <url-pattern>/loginServlet</url-pattern>\n    </servlet-mapping>\n</web-app>\n~~~\n\n### 在login.html中添加base标签并修改引入文件的路径：\n\n~~~html\n    <!--写base标签，永远固定相对路径跳转的结果-->\n    <base href=\"http://localhost:8080/book/\">\n~~~\n\n### 在login.html中修改action和method：\n\n~~~html\n<form action=\"loginServlet\" method=\"post\"></form>\n~~~\n\n', '2020-10-01 16:47:27', 0);
INSERT INTO `tb_blog` VALUES (8, 1, 'HTML-10.12作业', '登录界面与用户注册及表单验证', '# HTML-10.12作业\n## 登录界面与用户注册及表单验证\n[登录界面](http://cxycyq.gitee.io/html-job/HTML-10.12/html/index.html)\n\n[表单验证](http://cxycyq.gitee.io/html-job/HTML-10.12/html/form.html)\n\n![登录界面](http://cxycyq.gitee.io/my-blgo/images/effect/effect6.png)\n\n![表单验证](http://cxycyq.gitee.io/my-blgo/images/effect/effect5.png)', '2020-10-13 10:02:29', 0);
INSERT INTO `tb_blog` VALUES (21, 1, 'HTML-10.26作业', 'HTML5首页、中岚签证', '# HTML-10.26作业\n\n## HTML5首页、中岚签证\n\n[HTML5首页](http://cxycyq.gitee.io/html-job/HTML-10.26/html/index.html)\n\n[中岚签证](http://cxycyq.gitee.io/html-job/HTML-10.26/html/mobile.html)\n\n![HTML5首页](http://cxycyq.gitee.io/my-blgo/images/effect/effect7.png)\n\n![中岚签证](http://cxycyq.gitee.io/my-blgo/images/effect/effect8.png)', '2020-10-27 11:06:21', 0);

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `status` int(5) NULL DEFAULT 1,
  `created` datetime(0) NULL DEFAULT NULL,
  `last_login` datetime(0) NULL DEFAULT NULL,
  `restrict` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限管理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES (1, 'admin', 'http://cxycyq.gitee.io/my-blgo/images/avatar.jpg', 'admin@163.com', '21232f297a57a5a743894a0e4a801fc3', 1, '2020-10-22 20:27:11', NULL, '1');
INSERT INTO `tb_user` VALUES (3, '123', 'http://cxycyq.gitee.io/my-blgo/images/connection.png', '123@qq.com', '202cb962ac59075b964b07152d234b70', 1, NULL, NULL, '2');

SET FOREIGN_KEY_CHECKS = 1;
